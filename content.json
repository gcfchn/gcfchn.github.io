{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"John Doe","url":"http://yoursite.com","root":"/"},"pages":[{"title":"页面名","date":"2019-03-22T07:53:11.000Z","updated":"2019-03-22T07:53:11.225Z","comments":true,"path":"页面名/index.html","permalink":"http://yoursite.com/页面名/index.html","excerpt":"","text":""}],"posts":[{"title":"BlockCanary解析","slug":"2019-03-22-BlockCanary解析","date":"2019-03-21T16:00:00.000Z","updated":"2019-03-22T10:00:02.571Z","comments":true,"path":"2019/03/22/2019-03-22-BlockCanary解析/","link":"","permalink":"http://yoursite.com/2019/03/22/2019-03-22-BlockCanary解析/","excerpt":"BlockCanary是一套性能监控组件，主要实现对主线程操作的完全透明的监控，输出有效的监控信息，功能包括核心监控输出文件可在后台上传，以及弹出通知并UI显示卡顿信息，可以帮助开发者快速分析、定位到卡顿问题所在，精准定位问题代码行，并具有非侵入式的特点。下面是对BlockCanary的原理和代码的解析。","text":"BlockCanary是一套性能监控组件，主要实现对主线程操作的完全透明的监控，输出有效的监控信息，功能包括核心监控输出文件可在后台上传，以及弹出通知并UI显示卡顿信息，可以帮助开发者快速分析、定位到卡顿问题所在，精准定位问题代码行，并具有非侵入式的特点。下面是对BlockCanary的原理和代码的解析。BlockCanary是一套性能监控组件，主要实现对主线程操作的完全透明的监控，输出有效的监控信息，功能包括核心监控输出文件可在后台上传，以及弹出通知并UI显示卡顿信息，可以帮助开发者快速分析、定位到卡顿问题所在，精准定位问题代码行，并具有非侵入式的特点。下面是对BlockCanary的原理和代码的解析。 1.基本原理每一个Android应用程序中只有一个主线程，会在主线程自动创建一个Looper，并关联一个MessageQueue消息队列，主线程的Looper会在应用的生命周期内不轮询轮消息队列，从MessageQueue取出Message并处理从实现UI的更新，并且是顺序串行执行的，那么前面一个Message还没处理完的话，loop()就会等待它处理完了才会再去执行下一个Message，如果前面一Message处理很慢，那就会造成卡顿了。 下面是Looper.loop()方法1234567891011121314151617181920public static void loop() &#123; ... for (;;) &#123; //取消息 Message msg = queue.next(); //打印日志 final Printer logging = me.mLogging; if (logging != null) &#123; logging.println(\"&gt;&gt;&gt;&gt;&gt; Dispatching to \" + msg.target + \" \" + msg.callback + \": \" + msg.what); &#125; //消息处理 msg.target.dispatchMessage(msg); if (logging != null) &#123; logging.println(\"&lt;&lt;&lt;&lt;&lt; Finished to \" + msg.target + \" \" + msg.callback); &#125; ... &#125; &#125; 其中的msg.target其实是一个Handler,其调用的dispatchMessage()方法的代码如下1234567891011121314public void dispatchMessage(Message msg) &#123; if (msg.callback != null) &#123; //处理Handler.post(runnable)方式投递的消息 handleCallback(msg); &#125; else &#123; if (mCallback != null) &#123; //处理Handler.sendMessage(msg)方式投递的消息 if (mCallback.handleMessage(msg)) &#123; return; &#125; &#125; handleMessage(msg); &#125; &#125; 可以看到如果消息是通过Handler.post(runnable)方式投递到MessageQueu中的，就回调runnable#run方法；如果消息是通过Handler.sendMessage(msg)的方式投递到MessageQueu中，则回调handleMessage方法；而最终的消息回调一定发生在UI线程。因此如果应用发生卡顿的情况，一定是在dispatchMessage中执行了耗时操作。而Android提供了Looper.getMainLooper().setMessageLogging(Printer printer)，这样可以通过给主线程的Looper设置一个Printer，计算打印这两个log的时间差，就可以统计dispatchMessage方法执行的时间，如果超出设定的阀值，表示发生了卡顿，则dump出各种信息，提供开发者分析性能问题。 2.源码分析我们从框架的初始化方法install()开始分析BlockCanary的实现监控的过程。 BlockCanary.install()方法123456789101112131415161718192021222324252627282930//主要是初始化用户配置信息及配置DisplayActivity是否可用public static BlockCanary install(Context context, BlockCanaryContext blockCanaryContext) &#123; //blockCanaryContext是用户配置的参，数包括阈值、用户id、网络类型等 BlockCanaryContext.init(context, blockCanaryContext); //根据用户设置的是否打开显示通知来设置DisplayActivity是否可用，DisplayActivity是展示监控信息的Activity setEnabled(context, DisplayActivity.class, BlockCanaryContext.get().displayNotification()); //实例化BlockCanary return get();&#125;private static void setEnabled(Context context, final Class&lt;?&gt; componentClass, final boolean enabled) &#123; final Context appContext = context.getApplicationContext(); //在io线程执行 executeOnFileIoThread(new Runnable() &#123; @Override public void run() &#123; setEnabledBlocking(appContext, componentClass, enabled); &#125; &#125;);&#125; private static void setEnabledBlocking(Context appContext,Class&lt;?&gt; componentClass,boolean enabled) &#123; ComponentName component = new ComponentName(appContext, componentClass); PackageManager packageManager = appContext.getPackageManager(); int newState = enabled ? COMPONENT_ENABLED_STATE_ENABLED : COMPONENT_ENABLED_STATE_DISABLED; //设置DisplayActivity是否可用 packageManager.setComponentEnabledSetting(component, newState, DONT_KILL_APP);&#125; BlockCanary对象通过单例实例化，主要为核心类BlockCanaryInternals的初始化调用，及为BlockCanaryInternals添加ui卡顿时拦截器123456789101112private BlockCanary() &#123; //BlockCanaryInternals为核心处理类 BlockCanaryInternals.setContext(BlockCanaryContext.get()); mBlockCanaryCore = BlockCanaryInternals.getInstance(); //为BlockCanaryInternals添加拦截器，BlockCanaryContext.get()对BlockInterceptor的默认实现是空的，实现该方法可自己处理卡顿后的逻辑 mBlockCanaryCore.addBlockInterceptor(BlockCanaryContext.get()); if (!BlockCanaryContext.get().displayNotification()) &#123; return; &#125; //添加拦截器，当发生卡顿时发送通知栏消息 mBlockCanaryCore.addBlockInterceptor(new DisplayService());&#125; 核心类BlockCanaryInternals的初始化12345678910111213141516171819202122232425262728293031323334353637383940public BlockCanaryInternals() &#123; //构造线程堆栈采样器 stackSampler = new StackSampler( Looper.getMainLooper().getThread(), sContext.provideDumpInterval()); //构造CPU采样器 cpuSampler = new CpuSampler(sContext.provideDumpInterval()); //通过Looper.getMainLooper().setMessageLogging(Printer printer)，设置一个主线程的Looper的Printer，实现了android.util.Printer，重写print(String x)方法 setMonitor(new LooperMonitor(new LooperMonitor.BlockListener() &#123; //当发生卡顿时回调该方法 @Override public void onBlockEvent(long realTimeStart, long realTimeEnd, long threadTimeStart, long threadTimeEnd) &#123; // Get recent thread-stack entries and cpu usage ArrayList&lt;String&gt; threadStackEntries = stackSampler .getThreadStackEntries(realTimeStart, realTimeEnd); if (!threadStackEntries.isEmpty()) &#123; //合成卡顿日志 BlockInfo blockInfo = BlockInfo.newInstance() .setMainThreadTimeCost(realTimeStart, realTimeEnd, threadTimeStart, threadTimeEnd) .setCpuBusyFlag(cpuSampler.isCpuBusy(realTimeStart, realTimeEnd)) .setRecentCpuRate(cpuSampler.getCpuRateInfo()) .setThreadStackEntries(threadStackEntries) .flushString(); //写卡顿日志到SD卡 LogWriter.save(blockInfo.toString()); //回调添加的卡顿通知的拦截器 if (mInterceptorChain.size() != 0) &#123; for (BlockInterceptor interceptor : mInterceptorChain) &#123; interceptor.onBlock(getContext().provideContext(), blockInfo); &#125; &#125; &#125; &#125; &#125;, getContext().provideBlockThreshold(), getContext().stopWhenDebugging())); LogWriter.cleanObsolete();&#125; 调用BlockCanary的start方法,将在BlockCanaryInternals中创建的LooperMonitor给主线程Looper的mLogging变量赋值。这样主线程Looper就可以消息分发前后使用LooperMonitor#println输出日志。 1234567public void start() &#123; if (!mMonitorStarted) &#123; mMonitorStarted = true; //设置一个我们自定义的主线程的Looper的Printer Looper.getMainLooper().setMessageLogging(mBlockCanaryCore.monitor); &#125;&#125; 根据上面原理的分析，监控的对象主要是Main Looper的Message分发耗时情况。主线程的所有消息都在这里调度。每从MessageQueu中取出一个消息，由于我们设置了Printer为LooperMonitor，因此在调用dispatchMessage前后都可以交由我们LooperMonitor接管，由LooperMonitor.println()处理。对于单个Message而言，logging.println(“ Dispatching”）及logging.println(Finished)成对出现，则这个方法一定的成对调用的第一次调用时，记录开始时间，并开始dump堆栈和CPU信息。123456789101112131415161718192021222324252627282930//LooperMonitor@Overridepublic void println(String x) &#123; //Debug模式下不开启监控的开关 if (mStopWhenDebugging &amp;&amp; Debug.isDebuggerConnected()) &#123; return; &#125; if (!mPrintingStarted) &#123; //第一次调用时走该分支 mStartTimestamp = System.currentTimeMillis(); mStartThreadTimestamp = SystemClock.currentThreadTimeMillis(); mPrintingStarted = true; //开始堆栈信息的dump startDump(); &#125; else &#123; //第二次调用时走该分支 final long endTime = System.currentTimeMillis(); mPrintingStarted = false; if (isBlock(endTime)) &#123; //回调onBlockEvent，生成日志，写日志并发送卡顿通知 notifyBlockEvent(endTime); &#125; //停止堆栈信息的dump的任务 stopDump(); &#125; //第二次与第一次的时间间隔是否会超过阀值 private boolean isBlock(long endTime) &#123; return endTime - mStartTimestamp &gt; mBlockThresholdMillis; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637//LooperMonitor//开始dump堆栈和CPU信息采样private void startDump() &#123; //堆栈信息采样 if (null != BlockCanaryInternals.getInstance().stackSampler) &#123; BlockCanaryInternals.getInstance().stackSampler.start(); &#125; //CPU信息采样 if (null != BlockCanaryInternals.getInstance().cpuSampler) &#123; BlockCanaryInternals.getInstance().cpuSampler.start(); &#125;&#125; //AbstractSamplerpublic void start() &#123; if (mShouldSample.get()) &#123; return; &#125; mShouldSample.set(true); HandlerThreadFactory.getTimerThreadHandler().removeCallbacks(mRunnable); HandlerThreadFactory.getTimerThreadHandler().postDelayed(mRunnable, BlockCanaryInternals.getInstance().getSampleDelay());&#125; //每隔采样时间进行一次采样,采样时间为设置的卡顿阈值的0.8倍private Runnable mRunnable = new Runnable() &#123; @Override public void run() &#123; doSample(); if (mShouldSample.get()) &#123; HandlerThreadFactory.getTimerThreadHandler() .postDelayed(mRunnable, mSampleInterval); &#125; &#125;&#125;; 两种采样依次提交到HandlerThread中进行，从而保证采样过程是在一个后台线程执行，并且不会被主线程堵塞。两种采样方法有个共同的父类AbstractSampler，采用了模板方法模式，即在父类定义了采样的抽象算法doSample及采样生命周期的管控（start和stop），不同的子类采样的算法实现是不一样的。采样时间为设置的卡顿阈值的0.8倍。通过0.8 mSampleInterval（卡顿时长阀值）后的去获取线程的堆栈信息并保存到sStackMap中，这里的意思是，我们认为方法执行超过mSampleInterval就表示卡顿，当方法执行时间已经到了mSampleInterval的0.8倍的时候还没执行完，那么这时候就开始采集方法执行堆栈信息了，如果方法在0.9 mSampleInterval的时候执行完成，那么不会警告卡顿，但是如果方法执行耗时超过mSampleInterval，那就把0.8 mSampleInterval这个时间点的堆栈信息认为是造成耗时原因的堆栈信息，而且，这里只要方法还没执行完，就会间隔mSampleInterval去再次获取函数执行堆栈信息并保存，这里之所以遥在0.8 mSampleInterval的时候就去获取堆栈信息时为了获取到准确的堆栈信息，因为既然函数耗时已经达到0.8 * mSampleInterval了，并且函数还没执行结束，那么很大概率上会导致卡顿了，所以提前获取函数执行堆栈保证获取到造成卡顿的函数调用堆栈的正确性，后面又不断间隔mSampleInterval去获取函数执行堆栈式要获取到更多完整的堆栈信息，当方法执行完成后就会停止获取函数执行堆栈了，所有的函数执行堆栈信息最多存100条，也就是最多有100个函数调用堆栈，以当前的时间戳作为key，当监测到卡顿的时候，要把之前保存在sStackMap的函数堆栈信息展示通知出来，通过时间戳就能取到。 堆栈采样很简单，直接通过Main Looper获取到主线程Thread对象，调用Thread#getStackTrace即可获取到堆栈信息。 1234567891011121314151617@Overrideprotected void doSample() &#123; StringBuilder stringBuilder = new StringBuilder(); for (StackTraceElement stackTraceElement : mCurrentThread.getStackTrace()) &#123; stringBuilder .append(stackTraceElement.toString()) .append(BlockInfo.SEPARATOR); &#125; synchronized (sStackMap) &#123; if (sStackMap.size() == mMaxEntryCount &amp;&amp; mMaxEntryCount &gt; 0) &#123; sStackMap.remove(sStackMap.keySet().iterator().next()); &#125; sStackMap.put(System.currentTimeMillis(), stringBuilder.toString()); &#125;&#125; cpu的采样是采集当前cpu的使用率，如果cpu使用率太高，可能会导致cpu处理来不及，所以函数执行到一半可能暂时挂起，等待cpu重新调度。主要通过统计/proc/stat（CPU的活动信息）及/proc/pid/stat文件（该文件包含了某一进程所有的活动的信息）中的时间，计算各个时间量utime、stime、cutime、cstime的占比得到。","categories":[{"name":"源码解析","slug":"源码解析","permalink":"http://yoursite.com/categories/源码解析/"}],"tags":[{"name":"性能","slug":"性能","permalink":"http://yoursite.com/tags/性能/"},{"name":"源码","slug":"源码","permalink":"http://yoursite.com/tags/源码/"},{"name":"第三方库","slug":"第三方库","permalink":"http://yoursite.com/tags/第三方库/"}]}]}