{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"John Doe","url":"http://yoursite.com","root":"/"},"pages":[{"title":"about","date":"2019-03-23T03:26:46.000Z","updated":"2019-03-23T03:27:50.751Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-03-23T03:26:21.000Z","updated":"2019-03-23T03:28:11.097Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"friends","date":"2019-03-23T03:26:34.000Z","updated":"2019-03-23T03:28:35.751Z","comments":true,"path":"friends/index.html","permalink":"http://yoursite.com/friends/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-03-23T03:22:55.000Z","updated":"2019-03-23T03:23:49.670Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"面向对象设计模式六大原则","slug":"面向对象设计模式六大原则","date":"2019-04-24T16:00:00.000Z","updated":"2019-04-25T03:29:03.612Z","comments":true,"path":"2019/04/25/面向对象设计模式六大原则/","link":"","permalink":"http://yoursite.com/2019/04/25/面向对象设计模式六大原则/","excerpt":"有软件开发经验的朋友应该有这样的体会：构建一个优秀的系统最困难之处不在于编码（Coding），而是在早期做出的设计（Design）上的决定。设计是软件开发生命周期中的关键阶段，好的设计能产生好的产品，而不当的设计则会影响最终产品的质量。设计的重要性已经深入人心，这从人们热烈讨论和研究设计模式就能看出来。设计模式是拥有多年开发设计经验的人给我们的经验传承，它是作为专家的建议而引入的，它背后的真正威力是其对真实世界的抽象。如果我们没有足够的经验，我们很难做出好的设计，但是富有经验的开发者和设计者以设计模式的形式将他们的经验传授给我们，拥有了这些经验之后，我们也能做出好的设计来了。不仅如此，设计模式还提高了我们软件复用的水平，从而提高了生产效率。本文对面向对象编程的设计模式的六大原则进行介绍。","text":"有软件开发经验的朋友应该有这样的体会：构建一个优秀的系统最困难之处不在于编码（Coding），而是在早期做出的设计（Design）上的决定。设计是软件开发生命周期中的关键阶段，好的设计能产生好的产品，而不当的设计则会影响最终产品的质量。设计的重要性已经深入人心，这从人们热烈讨论和研究设计模式就能看出来。设计模式是拥有多年开发设计经验的人给我们的经验传承，它是作为专家的建议而引入的，它背后的真正威力是其对真实世界的抽象。如果我们没有足够的经验，我们很难做出好的设计，但是富有经验的开发者和设计者以设计模式的形式将他们的经验传授给我们，拥有了这些经验之后，我们也能做出好的设计来了。不仅如此，设计模式还提高了我们软件复用的水平，从而提高了生产效率。本文对面向对象编程的设计模式的六大原则进行介绍。 1.单一职责原则就一个类而言，只有一个引起它变化的原因。一个类值负责一个功能，解耦不同功能类。举例：分开定义imageLoader的缓存实现类与图片展示的主类。 2.开闭原则对扩展开放，对修改封闭。尽可能通过扩展来实现变化，而不是通过修改已有的代码来实现。避免修改时将错误引入到已经经过测试的代码中，破坏原有系统。实现开闭原则主要使用抽象。举例：imageLoader的图片缓存使用策略模式。修改缓存策略时只要修改具体的缓存实现类，不需要改动ImageLoader类中的代码。 3.里氏替换原则所有引用基类的地方，必须能透明的使用其子类对象。只要父类能出现的地方子类就可以出现，而且替换为子类也不会有任何错误和异常。通过抽象建立规范，具体的实现在运行时替换抽象，保证系统的灵活性和扩展性。通常利用里氏替换原则来实现开闭原则。举例：imageLoader的图片缓存使用策略模式。ImageLoader类中依赖接口ImageCache，运行时利用内存缓存、磁盘缓存和双缓存实现类替换抽象类。 4.依赖倒置原则a.高层模块（调用端）不应该依赖于底层模块（具体实现类），两者都应该依赖其抽象；b.抽象（接口或抽象类）不应该依赖细节（具体实现类）；c.细节应该依赖抽象；在java中的表现：模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖是通过接口或者抽象类产生的。面向抽象编程。如果类与类之间直接依赖与细节，则它们之间存在着直接耦合，当具体的实现类要发生变化时，要同时修改依赖着的代码，限制了系统的可扩展性。举例：imageLoader的图片缓存使用策略模式。ImageLoader类中依赖接口ImageCache，而不是具体的实现类。 5.接口隔离原则客户端不应该依赖它不需要的接口。类间的依赖关系应该建立在最小的接口上。应该将庞大的接口，拆分成更小的、更具体的接口。举例：CloseAble接口；ImageLoader中的ImageCache接口，只需要知道该接口的实现对象具有存、取缓存图片的功能。 这五大原则可以归纳成三个关键字：抽象、单一职责、最小化。 6.最小知识原则又称迪米特原则。一个对象应对其它对象有最少的了解。与直接的朋友通信。一个类应该对自己要调用和耦合的类知道的最少，只需要知道它需要使用的方法即可，无需了解被调用类的内部实现。举例：用户只要与直接的朋友ImageLoader类打交道，而不需要了解具体的图片缓存如何实现。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"},{"name":"开发原则","slug":"开发原则","permalink":"http://yoursite.com/tags/开发原则/"},{"name":"编程思想","slug":"编程思想","permalink":"http://yoursite.com/tags/编程思想/"},{"name":"面向对象","slug":"面向对象","permalink":"http://yoursite.com/tags/面向对象/"}]},{"title":"EventBus 3.0的使用与源码解析","slug":"EventBus 3.0的使用与源码解析","date":"2019-04-10T16:00:00.000Z","updated":"2019-04-26T02:05:44.684Z","comments":true,"path":"2019/04/11/EventBus 3.0的使用与源码解析/","link":"","permalink":"http://yoursite.com/2019/04/11/EventBus 3.0的使用与源码解析/","excerpt":"当我们在进行Android项目开发的时候，通常要遇到需要在应用程序的各组之间、组件与后台线程之间进行通信，比如在子线程中进行数据的请求，当数据请求完毕后通过Handler或者是广播通知UI更新，而两个Fragment之间可以通过注册Listener进行通信等等。但是使用Intent、Handler、Broadcast进行组件之间、组件与后台线程之间进行通信，会增加大量代码，并且导致各通信模块之间的高度耦合。本文将EventBus 3.0的使用及相关的原理进行介绍。","text":"当我们在进行Android项目开发的时候，通常要遇到需要在应用程序的各组之间、组件与后台线程之间进行通信，比如在子线程中进行数据的请求，当数据请求完毕后通过Handler或者是广播通知UI更新，而两个Fragment之间可以通过注册Listener进行通信等等。但是使用Intent、Handler、Broadcast进行组件之间、组件与后台线程之间进行通信，会增加大量代码，并且导致各通信模块之间的高度耦合。本文将EventBus 3.0的使用及相关的原理进行介绍。 1.使用EventBus的意义EventBus是一个基于观察者模式的事件发布/订阅框架，不需要以层层传递接口的形式去单独构建通信桥梁，能够简化各组件间的通信，有效地分离事件发送方和接收，能避免复杂和容易出错的依赖性和生命周期问题，同时简化代码的书写。 2.EventBus 3.0的使用EventBus事件通信的三要素： Event 事件。它可以是任意类型。 Subscriber 事件订阅者。在EventBus3.0的订阅者事件处理的方法名可以随意取，不过需要加上注解@subscribe()，并且指定线程模型，默认是POSTING。 Publisher 事件的发布者。我们可以在任意线程里发布事件，一般情况下，使用EventBus.getDefault()就可以得到一个EventBus对象，然后再调用post(Object)方法即可。 EventBus3.0的四种线程模型： POSTING (默认) 表示事件处理函数的线程跟发布事件的线程在同一个线程。 MAIN 表示事件处理函数的线程在主线程(UI线程)，因此在这里不能进行耗时操作。 BACKGROUND 表示事件处理函数的线程在后台线程，因此不能进行UI操作。如果发布事件的线程是主线程(UI线程)，那么事件处理函数将会开启一个后台线程，如果果发布事件的线程是在后台线程，那么事件处理函数就使用该线程。 ASYNC 表示无论事件发布的线程是哪一个，事件处理函数始终会新建一个子线程运行，同样不能进行UI操作。 EventBus的基本用法1.首先需要在一个Activity里注册EventBus事件，然后定义接收方法，这跟Android里的广播机制很像，你需要首先注册广播，然后需要编写内部类，实现接收广播，然后操作UI。所以，在EventBus中，你同样得这么做。 1234567891011121314//自定义一个事件类public class MessageEvent&#123; private String message; public MessageEvent(String message)&#123; this.message=message; &#125; public String getMessage() &#123; return message; &#125; public void setMessage(String message) &#123; this.message = message; &#125;&#125; 这个类就是一个Bean类，里面定义用来传输的数据的类型。 2.当我们需要在Activity或者Fragment里订阅事件时，我们需要注册EventBus。我们一般选择在Activity的onCreate()方法里去注册EventBus，在onDestory()方法里，去解除注册。 1234567891011121314@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main)； //注册事件 EventBus.getDefault().register(this)；&#125;@Overrideprotected void onDestroy() &#123; super.onDestroy(); //解除注册 EventBus.getDefault().unregister(this);&#125; 3.在子线程或组件中发送事件12//发送事件EventBus.getDefault().post(messageEvent); 自定义处理事件的方法，处理消息的方法名字可以随便取。但是需要加一个注解@Subscribe，并且要指定线程模型。 12345//处理事件@Subscribe(threadMode = ThreadMode.MAIN)public void XXX(MessageEvent messageEvent) &#123; ...&#125; EventBus用法之粘性事件所谓粘性事件，就是在发送事件之后再订阅该事件也能收到该事件。请注意这里与普通事件的区别，普通事件是先注册在绑定。比如在项目中有这样的需求，在FirstActivity发送事件，到SecondActivity中做事件的处理。如果是使通过EventBus.getDefault.post(xx)发出的,在SecondActivity是接收不到消息的。主要原因是SecondActivit用于接收消息的EventBus还未完成注册，也就是发布者发了消息,但订阅者还未产生。粘性事件与普通事件处理差异如下：首先发送粘性事件 12//发送粘性事件EventBus.getDefault().postSticky(messageEvent); 以Sticky的形式发送的事件，在注册对象也要通过Sticky的形式进行处理事件 12345//处理粘性事件@Subscribe(threadMode = ThreadMode.MAIN,sticky = true)public void XXX(MessageEvent messageEvent) &#123; ...&#125; 3.EventBus 3.0源码解析在进入主题之前，我们先保持着这样几个疑问，EventBus的使用三要素里，我们为什么要去定义事件方法，并且用到了@subscribe()注解？EventBus.getDefault().register(Object)这行代码到底干了什么？发送事件的时候又做了哪些操作？为什么要在onDestory()做解除绑定的操作…等等 3.1注册:EventBus.getDefault().register(obj)首先调用EventBus的静态getDefault()方法返回一个EventBus对象，采用单例实现。 12345678910111213141516171819202122232425262728293031323334353637383940414243// 静态的单例static volatile EventBus defaultInstance;// 默认的EventBusBuilder对象private static final EventBusBuilder DEFAULT_BUILDER = new EventBusBuilder();// 使用了单例的双重检查锁机制public static EventBus getDefault() &#123; if (defaultInstance == null) &#123; synchronized (EventBus.class) &#123; if (defaultInstance == null) &#123; defaultInstance = new EventBus(); &#125; &#125; &#125; return defaultInstance; &#125; // 调用带参数的构造方法 public EventBus() &#123; this(DEFAULT_BUILDER); &#125;// EventBus(EventBusBuilder builder) &#123; //... subscriptionsByEventType = new HashMap&lt;&gt;(); typesBySubscriber = new HashMap&lt;&gt;(); stickyEvents = new ConcurrentHashMap&lt;&gt;(); mainThreadPoster = new HandlerPoster(this, Looper.getMainLooper(), 10); backgroundPoster = new BackgroundPoster(this); asyncPoster = new AsyncPoster(this); indexCount = builder.subscriberInfoIndexes != null ? builder.subscriberInfoIndexes.size() : 0; subscriberMethodFinder = new SubscriberMethodFinder(builder.subscriberInfoIndexes, builder.strictMethodVerification, builder.ignoreGeneratedIndex); logSubscriberExceptions = builder.logSubscriberExceptions; logNoSubscriberMessages = builder.logNoSubscriberMessages; sendSubscriberExceptionEvent = builder.sendSubscriberExceptionEvent; sendNoSubscriberEvent = builder.sendNoSubscriberEvent; throwSubscriberException = builder.throwSubscriberException; eventInheritance = builder.eventInheritance; executorService = builder.executorService; &#125; 在EventBus(builder)构造方法里初始化了一些配置信息。之后调用了EventBus的register(obj)方法，这个方法接收的参数类型是Object。这里我们分步骤1和步骤2去看看做了哪些操作。 12345678910111213public void register(Object subscriber) &#123; //通过反射拿到传入的obj的Class对象 //如果是在MainActivity里做的注册操作，那subscriber就是MainActivity对象 Class&lt;?&gt; subscriberClass = subscriber.getClass(); //步骤1 List&lt;SubscriberMethod&gt; subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass); //步骤2 synchronized (this) &#123; for (SubscriberMethod subscriberMethod : subscriberMethods) &#123; subscribe(subscriber, subscriberMethod); &#125; &#125;&#125; 步骤1:首先subscriberMethodFinder对象是在EventBus带参数的构造函数里进行初始化的，从这个findSubscriberMethods()方法名就可以看出来，步骤1的是去获取当前注册的对象里所有的被@Subscribe注解的方法集合，那这个List集合的对象SubscriberMethod又是什么东东呢？我们去看一下 12345678public class SubscriberMethod &#123; final Method method;//Method方法名 final ThreadMode threadMode;//线程模型 final Class&lt;?&gt; eventType;//事件的class对象 final int priority;//接收事件的优先级 final boolean sticky;//是否是粘性事件 String methodString;&#125; … SubscriberMethod对这些信息做了一个封装。这些信息在我们处理事件的时候都会用到：@Subscribe(threadMode = ThreadMode.MAIN,sticky = true) 123public void XXX(MessageEvent messageEvent) &#123; ...&#125; 好的，知道了SubscriberMethod是什么东东后，我们直接进入findSubscriberMethods(subscriberClass)方法。 123456789101112131415161718192021222324252627282930List&lt;SubscriberMethod&gt; findSubscriberMethods(Class&lt;?&gt; subscriberClass) &#123; //从缓存中获取SubscriberMethod集合 //METHOD_CACHE是事先定义了一个缓存Map //以当前的注册对象的Class对象为key //注册的对象里所有的被@Subscribe注解的方法集合为value List&lt;SubscriberMethod&gt; subscriberMethods = METHOD_CACHE.get(subscriberClass); //第一次进来的时候，缓存里面没有集合，subscriberMethods为null if (subscriberMethods != null) &#123; return subscriberMethods; &#125; //ignoreGeneratedIndex属性表示是否忽略注解器生成的MyEventBusIndex //ignoreGeneratedIndex是在SubscriberMethodFinder()的构造函数初始化的，默认值是 false, if (ignoreGeneratedIndex) &#123; //通过反射去获取 subscriberMethods = findUsingReflection(subscriberClass); &#125; else &#123; //通过apt插件生成的代码。使用subscriber Index生成的SubscriberInfo来获取订阅者的事件处理函数， subscriberMethods = findUsingInfo(subscriberClass); &#125; if (subscriberMethods.isEmpty()) &#123; //在获得subscriberMethods以后，如果订阅者中不存在@Subscribe注解并且为public的订阅方法，则会抛出异常。 //即注册了监听的模块必须有一个标注了Subscribe注解方法 throw new EventBusException(&quot;Subscriber &quot; + subscriberClass + &quot; and its super classes have no public methods with the @Subscribe annotation&quot;); &#125; else &#123; METHOD_CACHE.put(subscriberClass, subscriberMethods); return subscriberMethods; &#125;&#125; 首先是从缓存中获取，如果缓存中存在直接返回，这里使用缓存有一个好处，比如在MainActivity进行了注册操作，多次启动MainActivity，就会直接去缓存中拿数据。如果缓存里没有数据，就会根据ignoreGeneratedIndex 这个boolean值去调用不同的方法，ignoreGeneratedIndex 默认为false。如果此时，获取到的方法集合还是空的，程序就会抛出异常，提醒用户被注册的对象以及它的父类没有被@Subscribe注解的public方法（这里插一句，很多时候，如果打正式包的时候EventBus没有做混淆处理，就会抛出该异常，因为方法名被混淆处理了，EventBus会找不到），把获取到的方法集合存入到缓存中去，并且把方法集合return出去。我们在项目中经常通过调用EventBus.getDefault()的单例模式来获取默认的EventBus对象，也就是ignoreGeneratedIndex为false的情况，这种情况调用了findUsingInfo方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859private List&lt;SubscriberMethod&gt; findUsingInfo(Class&lt;?&gt; subscriberClass) &#123; //这里采用了享元设计模式 FindState findState = prepareFindState(); //初始化FindState里的参数 findState.initForSubscriber(subscriberClass); while (findState.clazz != null) &#123; //获取订阅者信息，没有配置MyEventBusIndex返回null //如果我们通过EventBusBuilder配置了MyEventBusIndex，便会获取到subscriberInfo，调用subscriberInfo的getSubscriberMethods方法便可以得到订阅方法相关的信息，这个时候就不在需要通过注解进行获取订阅方法。 findState.subscriberInfo = getSubscriberInfo(findState); if (findState.subscriberInfo != null) &#123; SubscriberMethod[] array = findState.subscriberInfo.getSubscriberMethods(); for (SubscriberMethod subscriberMethod : array) &#123; if (findState.checkAdd(subscriberMethod.method, subscriberMethod.eventType)) &#123; findState.subscriberMethods.add(subscriberMethod); &#125; &#125; &#125; else &#123; findUsingReflectionInSingleClass(findState); &#125; //通过反射来查找订阅方法 findState.moveToSuperclass(); &#125; return getMethodsAndRelease(findState); &#125;// 获取FindState对象采用了享元模式private FindState prepareFindState() &#123; synchronized (FIND_STATE_POOL) &#123; for (int i = 0; i &lt; POOL_SIZE; i++) &#123; FindState state = FIND_STATE_POOL[i]; if (state != null) &#123; FIND_STATE_POOL[i] = null; return state; &#125; &#125; &#125; return new FindState(); &#125;// FindState类定义的信息static class FindState &#123; final List&lt;SubscriberMethod&gt; subscriberMethods = new ArrayList&lt;&gt;(); final Map&lt;Class, Object&gt; anyMethodByEventType = new HashMap&lt;&gt;(); final Map&lt;String, Class&gt; subscriberClassByMethodKey = new HashMap&lt;&gt;(); final StringBuilder methodKeyBuilder = new StringBuilder(128); Class&lt;?&gt; subscriberClass; Class&lt;?&gt; clazz; boolean skipSuperClasses; SubscriberInfo subscriberInfo; void initForSubscriber(Class&lt;?&gt; subscriberClass) &#123; this.subscriberClass = clazz = subscriberClass; skipSuperClasses = false; subscriberInfo = null; &#125;......&#125; 获取FindState采用了享元模式，这里不多说。之后调用了 findState.initForSubscriber(subscriberClass)方法，只是为了给FindState对象里的一些信息进行赋值操作。再然后是一个 while循环，循环里首先调用getSubscriberInfo(findState)方法，点进去看一下，发现该方法返回null。这里留一个小疑问，getSubscriberInfo()方法什么时候不为null？？ 答案在最后一节的高级用法里 1234567891011121314151617181920private SubscriberInfo getSubscriberInfo(FindState findState) &#123; // findState.subscriberInfo在初始化的时候置为null，所以该if 分支不会执行 if (findState.subscriberInfo != null &amp;&amp; findState.subscriberInfo.getSuperSubscriberInfo() != null) &#123; SubscriberInfo superclassInfo = findState.subscriberInfo.getSuperSubscriberInfo(); if (findState.clazz == superclassInfo.getSubscriberClass()) &#123; return superclassInfo; &#125; &#125; // subscriberInfoIndexes初始化的时候也是null，并没有赋值 if (subscriberInfoIndexes != null) &#123; for (SubscriberInfoIndex index : subscriberInfoIndexes) &#123; SubscriberInfo info = index.getSubscriberInfo(findState.clazz); if (info != null) &#123; return info; &#125; &#125; &#125; return null;&#125; 所以findUsingInfo()的while循环里直接走了else分支：findUsingReflectionInSingleClass(findState)。也就是说findUsingInfo()方法的主要逻辑是由findUsingReflectionInSingleClass()方法去完成的(默认情况，不考虑使用apt)这里有个细节要看一下： 1234567891011121314while (findState.clazz != null) &#123; findState.subscriberInfo = getSubscriberInfo(findState); if (findState.subscriberInfo != null) &#123; SubscriberMethod[] array = findState.subscriberInfo.getSubscriberMethods(); for (SubscriberMethod subscriberMethod : array) &#123; if (findState.checkAdd(subscriberMethod.method, subscriberMethod.eventType)) &#123; findState.subscriberMethods.add(subscriberMethod); &#125; &#125; &#125; else &#123; findUsingReflectionInSingleClass(findState); &#125; findState.moveToSuperclass();&#125; 这个while循环什么时候结束呢？这是我们第一次看EventBus源码看到这里比较疑惑的地方，答案就在这个 findState.moveToSuperclass()里面。 123456789101112void moveToSuperclass() &#123; if (skipSuperClasses) &#123; clazz = null; &#125; else &#123; clazz = clazz.getSuperclass(); String clazzName = clazz.getName(); /** Skip system classes, this just degrades performance. */ if (clazzName.startsWith(&quot;java.&quot;) || clazzName.startsWith(&quot;javax.&quot;) || clazzName.startsWith(&quot;android.&quot;)) &#123; clazz = null; &#125; &#125; &#125; 我们可以看到去把clazz赋值为它的超类，直到没有父类为止，才返回clazz=null，循环也才终止。也就是说 这个while循环保证了，获取注解的方法不仅会从当前注册对象里去找，也会去从他的父类查找。好了，继续分析findUsingReflectionInSingleClass(findState)方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748private void findUsingReflectionInSingleClass(FindState findState) &#123; Method[] methods; try &#123; // 查找注册对象的所有方法，注意是所有 methods = findState.clazz.getDeclaredMethods(); &#125; catch (Throwable th) &#123; // Workaround for java.lang.NoClassDefFoundError, see https://github.com/greenrobot/EventBus/issues/149 methods = findState.clazz.getMethods(); findState.skipSuperClasses = true; &#125; // 执行遍历操作 for (Method method : methods) &#123; // 获取该方法的修饰符,即public、private等 int modifiers = method.getModifiers(); // 修饰符是public才会走该分支 if ((modifiers &amp; Modifier.PUBLIC) != 0 &amp;&amp; (modifiers &amp; MODIFIERS_IGNORE) == 0) &#123; // 这里是回去该方法的参数类型，String，in Class&lt;?&gt;[] parameterTypes = method.getParameterTypes(); // 只有一个参数会走该分支 if (parameterTypes.length == 1) &#123; // 如果该方法被@subscribe注解会走该分支 Subscribe subscribeAnnotation = method.getAnnotation(Subscribe.class); if (subscribeAnnotation != null) &#123; // 获取传入的对象的Class Class&lt;?&gt; eventType = parameterTypes[0]; if (findState.checkAdd(method, eventType)) &#123; // 获取注解上指定的 线程模型 ThreadMode threadMode = subscribeAnnotation.threadMode(); // 往集合中添加数据 findState.subscriberMethods.add(new SubscriberMethod(method, eventType, threadMode, subscribeAnnotation.priority(), subscribeAnnotation.sticky())); &#125; &#125; &#125; else if (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123; String methodName = method.getDeclaringClass().getName() + &quot;.&quot; + method.getName(); throw new EventBusException(&quot;@Subscribe method &quot; + methodName + &quot;must have exactly 1 parameter but has &quot; + parameterTypes.length); &#125; &#125; else if (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123; String methodName = method.getDeclaringClass().getName() + &quot;.&quot; + method.getName(); throw new EventBusException(methodName + &quot; is a illegal @Subscribe method: must be public, non-static, and non-abstract&quot;); &#125; &#125;&#125; findUsingReflectionInSingleClass()方法首先通过反射去拿到当前注册对象的所有的方法，然后去进行遍历，并进行第一次过滤，只针对修饰符是Public的方法，之后进行了第二次过滤，判断了方法的参数的个数是不是只有一个，如果满足，才去进一步的获取被@subscribe注解的方法。然后调用 1findState.subscriberMethods.add(new SubscriberMethod(method, eventType, threadMode,subscribeAnnotation.priority(), subscribeAnnotation.sticky())); 这行代码，new了一个SubscriberMethod()对象，传入参数，并添加到 findState.subscriberMethods的集合中去. 123static class FindState &#123; final List&lt;SubscriberMethod&gt; subscriberMethods = new ArrayList&lt;&gt;(); &#125; 之后，findUsingInfo()的getMethodsAndRelease(findState)方法回去获取刚刚设置的findState的subscriberMethods集合，并把它return出去。代码如下： 123456789101112131415private List&lt;SubscriberMethod&gt; getMethodsAndRelease(FindState findState) &#123; // 对subscriberMethods进行了赋值，return出去 List&lt;SubscriberMethod&gt; subscriberMethods = new ArrayList&lt;&gt;(findState.subscriberMethods); // 进行了回收 findState.recycle(); synchronized (FIND_STATE_POOL) &#123; for (int i = 0; i &lt; POOL_SIZE; i++) &#123; if (FIND_STATE_POOL[i] == null) &#123; FIND_STATE_POOL[i] = findState; break; &#125; &#125; &#125; return subscriberMethods;&#125; 步骤1总结：至此，以上就是EventBus获取一个注册对象的所有的被@subscribe注解的方法的集合的一个过程。该过程的主要方法流程为：(1) subscriberMethodFinder.findSubscriberMethods()(2) findUsingInfo()(3) findUsingReflectionInSingleClass()步骤2 123for (SubscriberMethod subscriberMethod : subscriberMethods) &#123; subscribe(subscriber, subscriberMethod); &#125; 通过步骤1，我们已经拿到了注册对象的所有的被@subscribe注解的方法的集合的。现在我们看看subscribe()都做了哪些操作。我们不妨想想，如果我们要去做subscribe()时，我们要考虑哪些问题，第一个问题是，要判断一下这些方法是不是已经注册过该事件了要不要考虑方法名是不是相同的问题。第二个问题是一个注册对象中有多个方法注册了该事件，我们该怎么保存这些方法，比如说事件类型是String,一个Activity里有两个方法注册了该事件，分别是onEvent1和onEvent2，那我是不是应该用一个Map集合，以事件类型为key，把onEvent1和onEvent2放到一个List集合中，把该List集合作为value。subscribe()方法： 1234567891011121314151617181920212223242526private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) &#123; //拿到事件event类型，比如是String或者自定义的对象 Class&lt;?&gt; eventType = subscriberMethod.eventType; //Subscription将注册对象和subscriberMethod 做为参数传入 Subscription newSubscription = new Subscription(subscriber, subscriberMethod); //subscriptionsByEventType是一个Map集合，key是事件类型，验证了我上面的猜想 CopyOnWriteArrayList&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType); //如果subscriptions是null,则new出一个CopyOnWriteArrayList，并且往Map集合中添加 if (subscriptions == null) &#123; subscriptions = new CopyOnWriteArrayList&lt;&gt;(); subscriptionsByEventType.put(eventType, subscriptions); &#125; else &#123; //这里做了if语句判断，判断一下List集合中是否存在，存在就抛异常 //如果不存在？怎么没有add操作？保持疑问 if (subscriptions.contains(newSubscription)) &#123; throw new EventBusException(&quot;Subscriber &quot; + subscriber.getClass() + &quot; already registered to event &quot; + eventType); &#125; &#125;&#125; 以上的操作验证了我之前的猜想，通过if (subscriptions.contains(newSubscription)) 这个if语句判断 是否发生了重复注册，注意这里重复注册的含义是 事件类型一致，以及方法名也一致。接下来我们看看如果一个注册对象重复注册了事件Event(方法名不能一致)，优先级priority是如何设置的 12345678910int size = subscriptions.size();for (int i = 0; i &lt;= size; i++) &#123; // 这里判断subscriberMethod的优先级是否是大于集合中的subscriberMethod的优先级，如果是，把newSubscription插进去 // 这也表明了subscription中priority大的在前，这样在事件分发时就会先获取。 if (i == size || subscriberMethod.priority &gt; subscriptions.get(i).subscriberMethod.priority) &#123; subscriptions.add(i, newSubscription); break; &#125; &#125; if语句的条件subscriberMethod.priority &gt; subscriptions.get(i).subscriberMethod.priority) ，保证了subscription中priority大的在前。同时i == size 这个条件也保证了priority小的也会添加到subscriptions集合中去紧接着我们看看EventBus是如何处理粘性事件的 123456789101112131415161718192021222324252627List&lt;Class&lt;?&gt;&gt; subscribedEvents = typesBySubscriber.get(subscriber); if (subscribedEvents == null) &#123; subscribedEvents = new ArrayList&lt;&gt;(); typesBySubscriber.put(subscriber, subscribedEvents); &#125; subscribedEvents.add(eventType); if (subscriberMethod.sticky) &#123; if (eventInheritance) &#123; // Existing sticky events of all subclasses of eventType have to be considered. // Note: Iterating over all events may be inefficient with lots of sticky events, // thus data structure should be changed to allow a more efficient lookup // (e.g. an additional map storing sub classes of super classes: Class -&gt; List&lt;Class&gt;). Set&lt;Map.Entry&lt;Class&lt;?&gt;, Object&gt;&gt; entries = stickyEvents.entrySet(); for (Map.Entry&lt;Class&lt;?&gt;, Object&gt; entry : entries) &#123; Class&lt;?&gt; candidateEventType = entry.getKey(); if (eventType.isAssignableFrom(candidateEventType)) &#123; Object stickyEvent = entry.getValue(); checkPostStickyEventToSubscription(newSubscription, stickyEvent); &#125; &#125; &#125; else &#123; Object stickyEvent = stickyEvents.get(eventType); checkPostStickyEventToSubscription(newSubscription, stickyEvent); &#125; &#125;&#125; 注意以上代码有四行比较重要的注释信息。大致的意思是必须考虑eventType所有子类的现有粘性事件，在迭代的过程中，所有的event可能会因为大量的sticky events变得低效，为了使得查询变得高效应该改变数据结构。isAssignableFrom方法的意思是判断candidateEventType是不是eventType的子类或者子接口，如果postSticky()的参数是子Event,那么@Subscribe注解方法中的参数是父Event也可以接收到此消息。拿到粘性Event后，调用了checkPostStickyEventToSubscription()方法，改方法内部方法内部调用了postToSubscription()private void checkPostStickyEventToSubscription(Subscription newSubscription, Object stickyEvent) { if (stickyEvent != null) { // If the subscriber is trying to abort the event, it will fail (event is not tracked in posting state) // –&gt; Strange corner case, which we don’t take care of here. postToSubscription(newSubscription, stickyEvent, Looper.getMainLooper() == Looper.myLooper()); } } 步骤2总结：至此，EventBus的注册操作已经全部分析完了，需要注意的是，粘性事件是在subscribe中进行post的(二) 发送事件：EventBus.getDefault().post(xxx);普通Event 1234567891011121314151617181920212223public void post(Object event) &#123; PostingThreadState postingState = currentPostingThreadState.get(); List&lt;Object&gt; eventQueue = postingState.eventQueue; // 将Event添加到List集合中去 eventQueue.add(event); if (!postingState.isPosting) &#123; postingState.isMainThread = Looper.getMainLooper() == Looper.myLooper(); postingState.isPosting = true; if (postingState.canceled) &#123; throw new EventBusException(&quot;Internal error. Abort state was not reset&quot;); &#125; try &#123; // 遍历这个list集合，条件是集合是否是空的 while (!eventQueue.isEmpty()) &#123; postSingleEvent(eventQueue.remove(0), postingState); &#125; &#125; finally &#123; postingState.isPosting = false; postingState.isMainThread = false; &#125; &#125;&#125; 首先将当前的 Event添加到eventQueue中去，并且while循环，处理post每一个Event事件，调用的是 postSingleEvent(eventQueue.remove(0), postingState); 1234567891011121314151617181920private void postSingleEvent(Object event, PostingThreadState postingState) throws Error &#123; // 获取Event的Class对象 Class&lt;?&gt; eventClass = event.getClass(); boolean subscriptionFound = false; // eventInheritance初始化的时候值为true，所以会走该分支 if (eventInheritance) &#123; // 获取当前的Event的Class对象的所有父类的Class对象集合，优先从缓存里读取。 List&lt;Class&lt;?&gt;&gt; eventTypes = lookupAllEventTypes(eventClass); int countTypes = eventTypes.size(); for (int h = 0; h &lt; countTypes; h++) &#123; Class&lt;?&gt; clazz = eventTypes.get(h); subscriptionFound |= postSingleEventForEventType(event, postingState, clazz); &#125; &#125; else &#123; subscriptionFound = postSingleEventForEventType(event, postingState, eventClass); &#125; ... ...&#125; 这里lookupAllEventTypes()方法也是为了获取当前的Event的Class对象的所有父类的Class对象集合，优先从缓存里读取。之后是 for循环获取到的Class对象集合，调用postSingleEventForEventType()方法。 12345678910111213141516171819202122232425262728private boolean postSingleEventForEventType(Object event, PostingThreadState postingState, Class&lt;?&gt; eventClass) &#123; CopyOnWriteArrayList&lt;Subscription&gt; subscriptions; synchronized (this) &#123; // subscriptionsByEventType该map是在subscribe()方法中进行了put操作 subscriptions = subscriptionsByEventType.get(eventClass); &#125; if (subscriptions != null &amp;&amp; !subscriptions.isEmpty()) &#123; for (Subscription subscription : subscriptions) &#123; postingState.event = event; postingState.subscription = subscription; boolean aborted = false; try &#123; // 进行for循环并调用了postToSubscription() postToSubscription(subscription, event, postingState.isMainThread); aborted = postingState.canceled; &#125; finally &#123; postingState.event = null; postingState.subscription = null; postingState.canceled = false; &#125; if (aborted) &#123; break; &#125; &#125; return true; &#125; return false; &#125; postSingleEventForEventType()方法，主要是获取Event的Class对象所对应的一个List集合，集合的对象是Subscription参数。subscriptionsByEventType对象是在subscribe()方法中进行了赋值。for循环CopyOnWriteArrayList集合，并调用postToSubscription()；线程模型等执行到postToSubscription()方法时，线程模型才派上了用场。 12345678910111213141516171819202122232425private void postToSubscription(Subscription subscription, Object event, boolean isMainThread) &#123; switch (subscription.subscriberMethod.threadMode) &#123; case POSTING: invokeSubscriber(subscription, event); break; case MAIN: if (isMainThread) &#123; invokeSubscriber(subscription, event); &#125; else &#123; mainThreadPoster.enqueue(subscription, event); &#125; break; case BACKGROUND: if (isMainThread) &#123; backgroundPoster.enqueue(subscription, event); &#125; else &#123; invokeSubscriber(subscription, event); &#125; break; case ASYNC: asyncPoster.enqueue(subscription, event); break; default: throw new IllegalStateException(&quot;Unknown thread mode: &quot; + subscription.subscriberMethod.threadMode); &#125; 第一个分支：线程模型是POST，直接调用了invokeSubscriber()方法。 123456789void invokeSubscriber(Subscription subscription, Object event) &#123; try &#123; subscription.subscriberMethod.method.invoke(subscription.subscriber, event); &#125; catch (InvocationTargetException e) &#123; handleSubscriberException(subscription, event, e.getCause()); &#125; catch (IllegalAccessException e) &#123; throw new IllegalStateException(&quot;Unexpected exception&quot;, e); &#125; &#125; 很明显的看到，这是基于反射去调用方法，invoke方法接收两个参数，第一个参数是注册的对象，第二个参数是事件的Event。从这里就可以看出来，POST并没有去做线程的调度什么的，事件处理函数的线程跟发布事件的线程在同一个线程。第二个分支：线程模型是MAIN 首先判断了下事件发布的线程是不是主线程，如果是，执行invokeSubscriber()方法，invokeSubscriber()上面已经分析过，如果不是主线程，执行mainThreadPoster.enqueue(subscription, event)。mainThreadPoster是继承自Handler，从这里大概可以猜到，这一步是去做线程调度的。我们看一看mainThreadPoster的enqueue做了什么事： 123456789101112131415void enqueue(Subscription subscription, Object event) &#123; // 封装了一个PendIngPost PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event); synchronized (this) &#123; // 将PendIngPost压入队列 queue.enqueue(pendingPost); if (!handlerActive) &#123; handlerActive = true; // 调用了sendMessage() if (!sendMessage(obtainMessage())) &#123; throw new EventBusException(&quot;Could not send handler message&quot;); &#125; &#125; &#125; &#125; enqueue() 主要封装了一个PendingPost类，并把subscription和event作为参数传进去，紧接着把PendingPost压入到队列中去，然后发了一条消息sendMessage。熟悉Handler机制的同学知道，处理消息是在handleMessage()方法中完成的: 123456789101112131415161718192021222324252627282930public void handleMessage(Message msg) &#123; boolean rescheduled = false; try &#123; long started = SystemClock.uptimeMillis(); while (true) &#123; PendingPost pendingPost = queue.poll(); if (pendingPost == null) &#123; synchronized (this) &#123; // Check again, this time in synchronized pendingPost = queue.poll(); if (pendingPost == null) &#123; handlerActive = false; return; &#125; &#125; &#125; eventBus.invokeSubscriber(pendingPost); long timeInMethod = SystemClock.uptimeMillis() - started; if (timeInMethod &gt;= maxMillisInsideHandleMessage) &#123; if (!sendMessage(obtainMessage())) &#123; throw new EventBusException(&quot;Could not send handler message&quot;); &#125; rescheduled = true; return; &#125; &#125; &#125; finally &#123; handlerActive = rescheduled; &#125; &#125; 代码有点多，我们主要看一下，它接收到消息后，是做了什么处理。从队列中取了消息，并且调用了eventBus.invokeSubscriber(pendingPost)方法，回到EventBus类中。 12345678void invokeSubscriber(PendingPost pendingPost) &#123; Object event = pendingPost.event; Subscription subscription = pendingPost.subscription; PendingPost.releasePendingPost(pendingPost); if (subscription.active) &#123; invokeSubscriber(subscription, event); &#125; &#125; 该方法内部还是去调用了invokeSubscriber()方法。分析完线程模型为MAIN 的工作流程，不难做出结论，当发布事件所在的线程是在主线程时，我们不需要做线程调度，直接调用反射方法去执行。如果发布事件所在的线程不是在主线程，需要使用Handler做线程的调度，并最终调用反射方法去执行第三个分支：线程模型是BACKGROUND。如果事件发布的线程是在主线程，执行backgroundPoster.enqueue(subscription, event)，否则执行invokeSubscriber()。backgroundPoster实现了Runable接口: 12345678910public void enqueue(Subscription subscription, Object event) &#123; PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event); synchronized (this) &#123; queue.enqueue(pendingPost); if (!executorRunning) &#123; executorRunning = true; eventBus.getExecutorService().execute(this); &#125; &#125; &#125; 将PendingPost对象压入队列，然后调用eventBus.getExecutorService().execute(this)，交给线程池去进行处理，它的处理是在Runnable的run()中。 12345678910111213141516171819202122232425@Override public void run() &#123; try &#123; try &#123; while (true) &#123; PendingPost pendingPost = queue.poll(1000); if (pendingPost == null) &#123; synchronized (this) &#123; // Check again, this time in synchronized pendingPost = queue.poll(); if (pendingPost == null) &#123; executorRunning = false; return; &#125; &#125; &#125; eventBus.invokeSubscriber(pendingPost); &#125; &#125; catch (InterruptedException e) &#123; Log.w(&quot;Event&quot;, Thread.currentThread().getName() + &quot; was interruppted&quot;, e); &#125; &#125; finally &#123; executorRunning = false; &#125; &#125; 最重要的还是eventBus.invokeSubscriber(pendingPost)这行代码，上面已经分析过。第四个分支：线程模型是ASYNC。直接调用 asyncPoster.enqueue(subscription, event)，asyncPoster也是实现了Runnable接口，里面也是使用的线程池，具体的操作就不分析了，感兴趣的可以去看一下源码，跟上一步操作类似。(三) 高级用法EventBus3.0较之前的版本有了一次改造，在3.0之后增加了注解处理器，在程序的编译时候，就可以根据注解生成相对应的代码，相对于之前的直接通过运行时反射，大大提高了程序的运行效率，但是在3.0默认的还是通过反射去查找用@Subscribe标注的方法，一般在使用的时候基本都是这个模式。 那我们怎么配置让EventBus使用注解器生成的代码呢？EventBus官网apt介绍在这里我们重点提一下 EventBusBuilder类的： boolean ignoreGeneratedIndex;List subscriberInfoIndexes; subscriberInfoIndexes变量可以去使用注解处理器生成的代码。SubscriberInfoIndex 就是一个接口，而注解生成器生成的类也是继承的它，我们也可以自己去继承它，定制自己的需求，不需要反射的EventBus。我们再回过头来看一下注册过程的findUsingInfo()方法: 12345678910111213141516171819private List&lt;SubscriberMethod&gt; findUsingInfo(Class&lt;?&gt; subscriberClass) &#123; FindState findState = prepareFindState(); findState.initForSubscriber(subscriberClass); while (findState.clazz != null) &#123; findState.subscriberInfo = getSubscriberInfo(findState); if (findState.subscriberInfo != null) &#123; SubscriberMethod[] array = findState.subscriberInfo.getSubscriberMethods(); for (SubscriberMethod subscriberMethod : array) &#123; if (findState.checkAdd(subscriberMethod.method, subscriberMethod.eventType)) &#123; findState.subscriberMethods.add(subscriberMethod); &#125; &#125; &#125; else &#123; findUsingReflectionInSingleClass(findState); &#125; findState.moveToSuperclass(); &#125; return getMethodsAndRelease(findState); &#125; 我们在前面分析的时候，直接分析的 findUsingReflectionInSingleClass(findState)方法，因为getSubscriberInfo()返回null，那什么时候getSubscriberInfo()返回不为null呢 ？ 我们具体看看getSubscriberInfo()。 123456789101112131415161718private SubscriberInfo getSubscriberInfo(FindState findState) &#123; if (findState.subscriberInfo != null &amp;&amp; findState.subscriberInfo.getSuperSubscriberInfo() != null) &#123; SubscriberInfo superclassInfo = findState.subscriberInfo.getSuperSubscriberInfo(); if (findState.clazz == superclassInfo.getSubscriberClass()) &#123; return superclassInfo; &#125; &#125; // 判断subscriberInfoIndexes 是否为null，默认为null,当我们使用apt插件构建代码 的时候，可以手动的调用EventBusBuilder的addIndex，将subscriberInfoIndexes 进行赋值。 if (subscriberInfoIndexes != null) &#123; for (SubscriberInfoIndex index : subscriberInfoIndexes) &#123; SubscriberInfo info = index.getSubscriberInfo(findState.clazz); if (info != null) &#123; return info; &#125; &#125; &#125; return null; &#125; 当我们使用apt插件构建代码 的时候，可以手动的调用EventBusBuilder的addIndex()，将subscriberInfoIndexes 进行赋值。这样subscriberInfoIndexes 就不会为null，getSubscriberInfo()方法也就不会为null。findUsingInfo()也就不会调用反射去获取数据，从而提高了性能。如何使用新特性SubscriberIndex：在gradle文件做以下配置： 1234567891011121314android &#123; defaultConfig &#123; javaCompileOptions &#123; annotationProcessorOptions &#123; arguments = [ eventBusIndex : &apos;com.example.myapp.MyEventBusIndex&apos; ] &#125; &#125; &#125;&#125;dependencies &#123; compile &apos;org.greenrobot:eventbus:3.1.1&apos; annotationProcessor &apos;org.greenrobot:eventbus-annotation-processor:3.1.1&apos;&#125; 成功构建项目后，将为您生成使用eventBusIndex指定的类 。然后在设置EventBus时将其传递给它： 1EventBus.builder().ignoreGeneratedIndex(false).addIndex(new MyEventBusIndex()).installDefaultEventBus(); 1.老司机教你 “飙” EventBus 32.Android事件总线（二）EventBus3.0源码解析3.EventBus 3.0使用详解","categories":[{"name":"第三方源码解析","slug":"第三方源码解析","permalink":"http://yoursite.com/categories/第三方源码解析/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"http://yoursite.com/tags/多线程/"},{"name":"源码","slug":"源码","permalink":"http://yoursite.com/tags/源码/"},{"name":"线程通信","slug":"线程通信","permalink":"http://yoursite.com/tags/线程通信/"},{"name":"第三方","slug":"第三方","permalink":"http://yoursite.com/tags/第三方/"}]},{"title":"线程池使用与原理解析","slug":"线程池的使用与原理解析","date":"2019-03-31T16:00:00.000Z","updated":"2019-04-11T02:40:10.896Z","comments":true,"path":"2019/04/01/线程池的使用与原理解析/","link":"","permalink":"http://yoursite.com/2019/04/01/线程池的使用与原理解析/","excerpt":"线程池是实现对多线程管理的工具，可高效重用线程及控制并发，本文将对常用线程池的使用及相关的原理进行介绍。","text":"线程池是实现对多线程管理的工具，可高效重用线程及控制并发，本文将对常用线程池的使用及相关的原理进行介绍。 1.为什么要使用线程池在java编程中，对象的创建和销毁是很耗费资源的，创建一个对象要获取内存资源，为对未被引用的对象进行销毁的工作，虚拟机的垃圾回收机制将试图跟踪每一个对象。因此提高程序运行效率的途径之一就是尽可能地减少对象创建和销毁的次数，特别是针对一些很耗资源的对象。如何尽可能重用当前已存在的对象来持续输出服务，就是一些”池化资源”技术产生的原因。Android中许多常见的组件都都使用了”池化”的技术，如各种图片加载库，网络请求库。即使Android的消息传递机制中的Meaasge在使用Meaasge.obtain()时，就是使用的Meaasge池中的对象，因此这个概念很重要。本文将介绍的线程池技术同样符合这一思想。同时通过继承Thread类和实现runnalbe接口来实现多线程，缺乏统一的管理，多线程之间的竞争导致线程阻塞。使用线程池的优势在于： 重用线程池中的线程,减少因对象创建,销毁所带来的性能开销; 能有效地控制线程的最大并发数,提高系统资源利用率,同时避免过多的资源竞争,避免堵塞; 能够简化多线程的管理,使线程的使用简单、高效；2.什么是线程池假设一个线程完成一项任务所需时间为：T1 创建线程时间，T2 在线程中执行任务的时间，T3 销毁线程时间。如果：T1 + T3 远大于T2，则可以采用线程池，以提高服务性能。线程池技术正是关注如何缩短或调整T1,T3时间的技术，从而提高服务程序性能的。java中的线程池是通过Executor框架来实现的。其中ThreadPoolExecutor是线程池的具体实现类,一般使用的各种线程池都是基于这个类实现的。其构造方法如下： 12345678910public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) &#123; ... &#125; 其7个参数的含义如下：corePoolSize：线程池中核心线程的数量，默认情况下核心线程一直存活即使在空闲状态下;maximumPoolSize：线程池中允许的最大线程数；keepAliveTime： 线程最大空闲的时间，当空闲线程空闲时间超过该值则回收该线程；unit: keepAliveTime的时间单位是一个枚举类型;workQueue：存放任务的BlockingQueue队列; 阻塞队列（BlockingQueue）是用来控制线程同步的工具。如果BlockQueue是空的,从BlockingQueue取东西的操作将会被阻断进入等待状态,直到BlockingQueue进了东西才会被唤醒。同样,如果BlockingQueue是满的,任何试图往里存东西的操作也会被阻断进入等待状态,直到BlockingQueue里有空间才会被唤醒继续操作。 threadFactory: 新建线程工厂，为线程池创建线程；defaultHandler: 线程池的拒绝策略； 当向线程池中提交任务时，如果此时线程池中的线程已经饱和了，而且阻塞队列也已经满了，则线程池会选择一种拒绝策略来处理该任务。 重点讲解：其中比较容易让人误解的是：corePoolSize，maximumPoolSize，workQueue之间关系。 1.当线程池小于corePoolSize时，新提交任务将创建一个新线程执行任务，即使此时线程池中存在空闲线程。2.当线程池达到corePoolSize时，新提交任务将被放入workQueue中，等待线程池中任务调度执行3.当workQueue已满，且maximumPoolSize&gt;corePoolSize时，新提交任务会创建新线程执行任务4.在当前的任务数超过maxmumPoolSize+workQueue之和时，即当前线程数目超过maximumPoolSize，新提交任务由RejectedExecutionHandler处理5.当线程池中超过corePoolSize线程，空闲时间达到keepAliveTime时，关闭空闲线程6.当设置allowCoreThreadTimeOut(true)时，线程池中corePoolSize线程空闲时间达到keepAliveTime也将关闭 3.线程池的种类及使用场景可以通过配置线程池的参数，自定义线程池的工作方式，同时java已经根据常用应用场景配置了4中线程池，包括可缓存线程池（CachedThreadPool），定长线程池（FixedThreadPool），定时线程池（ScheduledThreadPool ）单线程化线程池（SingleThreadExecutor）。下面对此进行介绍。 自定义线程池的使用1234567891011121314151617181920212223242526272829303132 // 1. 创建线程池 // 创建时，通过配置线程池的参数，从而实现自己所需的线程池 Executor threadPool = new ThreadPoolExecutor( CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE, TimeUnit.SECONDS, sPoolWorkQueue, sThreadFactory ); // 2. 向线程池提交任务：execute（） // 传入 Runnable对象 threadPool.execute(new Runnable() &#123; @Override public void run() &#123; ... // 线程执行任务 &#125; &#125;);// 3. 关闭线程池shutdown() threadPool.shutdown();// 关闭线程的原理// a. 遍历线程池中的所有工作线程// b. 逐个调用线程的interrupt（）中断线程（注：无法响应中断的任务可能永远无法终止）// 也可调用shutdownNow（）关闭线程：threadPool.shutdownNow（）// 二者区别：// shutdown：设置线程池的状态为SHUTDOWN，然后中断所有没有正在执行任务的线程// shutdownNow：设置线程池的状态 为STOP，然后尝试停止所有的正在执行或暂停任务的线程，并返回等待执行任务的列表// 使用建议：一般调用shutdown（）关闭线程池；若任务不一定要执行完，则调用shutdownNow（） newCachedThreadPool： 底层：返回ThreadPoolExecutor实例，corePoolSize为0；maximumPoolSize为Integer.MAX_VALUE；keepAliveTime为60L；unit为TimeUnit.SECONDS；workQueue为SynchronousQueue(同步队列) 通俗：当有新任务到来，则插入到SynchronousQueue中，由于SynchronousQueue是同步队列，因此会在池中寻找可用线程来执行，若有可以线程则执行，若没有可用线程则创建一个线程来执行该任务；任何线程任务到来都会立刻执行，不需要等待。若池中线程空闲时间超过指定大小，则该线程会被销毁。 适用：执行大量、耗时少的线程任务。 newFixedThreadPool： 底层：返回ThreadPoolExecutor实例，接收参数为所设定线程数量nThread，corePoolSize为nThread，maximumPoolSize为nThread；keepAliveTime为0L(不限时)；unit为：TimeUnit.MILLISECONDS；WorkQueue为：new LinkedBlockingQueue()无解阻塞队列。 通俗：只有核心线程并且不会被回收、线程数量固定、任务队列无大小限制。如果池中的所有线程均在繁忙状态，对于新任务会进入阻塞队列中等待(无界的阻塞队列)。 适用：控制线程最大并发数，执行长期的任务，性能好很多。 newSingleThreadExecutor: 底层：FinalizableDelegatedExecutorService包装的ThreadPoolExecutor实例，corePoolSize为1；maximumPoolSize为1；keepAliveTime为0L；unit为：TimeUnit.MILLISECONDS；workQueue为：new LinkedBlockingQueue() 无界阻塞队列 通俗：创建只有一个线程的线程池，且线程的存活时间是无限的；当该线程正繁忙时，对于新任务会进入阻塞队列中(无界的阻塞队列)，保证所有任务按照指定顺序在一个线程中执行，不需要处理线程同步的问题。 适用：一个任务一个任务执行的场景，不适合并发但可能引起IO阻塞性及影响UI线程响应的操作，如数据库操作，文件操作等 NewScheduledThreadPool: 底层：创建ScheduledThreadPoolExecutor实例，corePoolSize为传递来的参数，maximumPoolSize为Integer.MAX_VALUE；keepAliveTime为0；unit为：TimeUnit.NANOSECONDS；workQueue为：new DelayedWorkQueue() 一个按超时时间升序排序的队列 通俗：创建一个固定大小的线程池，线程池内线程存活时间无限制，线程池可以支持定时及周期性任务执行，如果所有线程均处于繁忙状态，对于新任务会进入DelayedWorkQueue队列中，这是一种按照超时时间排序的队列结构 适用：定时或周期性执行任务的场景 示例： 123456789101112131415// 1. 创建 定时线程池对象 &amp; 设置线程池线程数量固定为5ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(5);// 2. 创建好Runnable类线程对象 &amp; 需执行的任务Runnable task =new Runnable()&#123; public void run()&#123; System.out.println(\"执行任务啦\"); &#125; &#125;;// 3. 向线程池提交任务：schedule（）scheduledThreadPool.schedule(task, 1, TimeUnit.SECONDS); // 延迟1s后执行任务scheduledThreadPool.scheduleAtFixedRate(task,10,1000,TimeUnit.MILLISECONDS);// 延迟10ms后、每隔1000ms执行任务// 4. 关闭线程池scheduledThreadPool.shutdown(); 未完待续。。。","categories":[{"name":"系统源码解析","slug":"系统源码解析","permalink":"http://yoursite.com/categories/系统源码解析/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"http://yoursite.com/tags/多线程/"},{"name":"源码","slug":"源码","permalink":"http://yoursite.com/tags/源码/"},{"name":"应用","slug":"应用","permalink":"http://yoursite.com/tags/应用/"}]},{"title":"BlockCanary解析","slug":"BlockCanary解析","date":"2019-03-21T16:00:00.000Z","updated":"2019-04-11T02:37:56.425Z","comments":true,"path":"2019/03/22/BlockCanary解析/","link":"","permalink":"http://yoursite.com/2019/03/22/BlockCanary解析/","excerpt":"BlockCanary是一套性能监控组件，主要实现对主线程操作的完全透明的监控，输出有效的监控信息，功能包括核心监控输出文件可在后台上传，以及弹出通知并UI显示卡顿信息，可以帮助开发者快速分析、定位到卡顿问题所在，精准定位问题代码行，并具有非侵入式的特点。下面是对BlockCanary的原理和代码的解析。","text":"BlockCanary是一套性能监控组件，主要实现对主线程操作的完全透明的监控，输出有效的监控信息，功能包括核心监控输出文件可在后台上传，以及弹出通知并UI显示卡顿信息，可以帮助开发者快速分析、定位到卡顿问题所在，精准定位问题代码行，并具有非侵入式的特点。下面是对BlockCanary的原理和代码的解析。BlockCanary是一套性能监控组件，主要实现对主线程操作的完全透明的监控，输出有效的监控信息，功能包括核心监控输出文件可在后台上传，以及弹出通知并UI显示卡顿信息，可以帮助开发者快速分析、定位到卡顿问题所在，精准定位问题代码行，并具有非侵入式的特点。下面是对BlockCanary的原理和代码的解析。 1.基本原理每一个Android应用程序中只有一个主线程，会在主线程自动创建一个Looper，并关联一个MessageQueue消息队列，主线程的Looper会在应用的生命周期内不轮询轮消息队列，从MessageQueue取出Message并处理从实现UI的更新，并且是顺序串行执行的，那么前面一个Message还没处理完的话，loop()就会等待它处理完了才会再去执行下一个Message，如果前面一Message处理很慢，那就会造成卡顿了。 下面是Looper.loop()方法1234567891011121314151617181920public static void loop() &#123; ... for (;;) &#123; //取消息 Message msg = queue.next(); //打印日志 final Printer logging = me.mLogging; if (logging != null) &#123; logging.println(\"&gt;&gt;&gt;&gt;&gt; Dispatching to \" + msg.target + \" \" + msg.callback + \": \" + msg.what); &#125; //消息处理 msg.target.dispatchMessage(msg); if (logging != null) &#123; logging.println(\"&lt;&lt;&lt;&lt;&lt; Finished to \" + msg.target + \" \" + msg.callback); &#125; ... &#125; &#125; 其中的msg.target其实是一个Handler,其调用的dispatchMessage()方法的代码如下1234567891011121314public void dispatchMessage(Message msg) &#123; if (msg.callback != null) &#123; //处理Handler.post(runnable)方式投递的消息 handleCallback(msg); &#125; else &#123; if (mCallback != null) &#123; //处理Handler.sendMessage(msg)方式投递的消息 if (mCallback.handleMessage(msg)) &#123; return; &#125; &#125; handleMessage(msg); &#125; &#125; 可以看到如果消息是通过Handler.post(runnable)方式投递到MessageQueu中的，就回调runnable#run方法；如果消息是通过Handler.sendMessage(msg)的方式投递到MessageQueu中，则回调handleMessage方法；而最终的消息回调一定发生在UI线程。因此如果应用发生卡顿的情况，一定是在dispatchMessage中执行了耗时操作。而Android提供了Looper.getMainLooper().setMessageLogging(Printer printer)，这样可以通过给主线程的Looper设置一个Printer，计算打印这两个log的时间差，就可以统计dispatchMessage方法执行的时间，如果超出设定的阀值，表示发生了卡顿，则dump出各种信息，提供开发者分析性能问题。 2.源码分析我们从框架的初始化方法install()开始分析BlockCanary的实现监控的过程。 BlockCanary.install()方法123456789101112131415161718192021222324252627282930//主要是初始化用户配置信息及配置DisplayActivity是否可用public static BlockCanary install(Context context, BlockCanaryContext blockCanaryContext) &#123; //blockCanaryContext是用户配置的参，数包括阈值、用户id、网络类型等 BlockCanaryContext.init(context, blockCanaryContext); //根据用户设置的是否打开显示通知来设置DisplayActivity是否可用，DisplayActivity是展示监控信息的Activity setEnabled(context, DisplayActivity.class, BlockCanaryContext.get().displayNotification()); //实例化BlockCanary return get();&#125;private static void setEnabled(Context context, final Class&lt;?&gt; componentClass, final boolean enabled) &#123; final Context appContext = context.getApplicationContext(); //在io线程执行 executeOnFileIoThread(new Runnable() &#123; @Override public void run() &#123; setEnabledBlocking(appContext, componentClass, enabled); &#125; &#125;);&#125; private static void setEnabledBlocking(Context appContext,Class&lt;?&gt; componentClass,boolean enabled) &#123; ComponentName component = new ComponentName(appContext, componentClass); PackageManager packageManager = appContext.getPackageManager(); int newState = enabled ? COMPONENT_ENABLED_STATE_ENABLED : COMPONENT_ENABLED_STATE_DISABLED; //设置DisplayActivity是否可用 packageManager.setComponentEnabledSetting(component, newState, DONT_KILL_APP);&#125; BlockCanary对象通过单例实例化，主要为核心类BlockCanaryInternals的初始化调用，及为BlockCanaryInternals添加ui卡顿时拦截器123456789101112private BlockCanary() &#123; //BlockCanaryInternals为核心处理类 BlockCanaryInternals.setContext(BlockCanaryContext.get()); mBlockCanaryCore = BlockCanaryInternals.getInstance(); //为BlockCanaryInternals添加拦截器，BlockCanaryContext.get()对BlockInterceptor的默认实现是空的，实现该方法可自己处理卡顿后的逻辑 mBlockCanaryCore.addBlockInterceptor(BlockCanaryContext.get()); if (!BlockCanaryContext.get().displayNotification()) &#123; return; &#125; //添加拦截器，当发生卡顿时发送通知栏消息 mBlockCanaryCore.addBlockInterceptor(new DisplayService());&#125; 核心类BlockCanaryInternals的初始化12345678910111213141516171819202122232425262728293031323334353637383940public BlockCanaryInternals() &#123; //构造线程堆栈采样器 stackSampler = new StackSampler( Looper.getMainLooper().getThread(), sContext.provideDumpInterval()); //构造CPU采样器 cpuSampler = new CpuSampler(sContext.provideDumpInterval()); //通过Looper.getMainLooper().setMessageLogging(Printer printer)，设置一个主线程的Looper的Printer，实现了android.util.Printer，重写print(String x)方法 setMonitor(new LooperMonitor(new LooperMonitor.BlockListener() &#123; //当发生卡顿时回调该方法 @Override public void onBlockEvent(long realTimeStart, long realTimeEnd, long threadTimeStart, long threadTimeEnd) &#123; // Get recent thread-stack entries and cpu usage ArrayList&lt;String&gt; threadStackEntries = stackSampler .getThreadStackEntries(realTimeStart, realTimeEnd); if (!threadStackEntries.isEmpty()) &#123; //合成卡顿日志 BlockInfo blockInfo = BlockInfo.newInstance() .setMainThreadTimeCost(realTimeStart, realTimeEnd, threadTimeStart, threadTimeEnd) .setCpuBusyFlag(cpuSampler.isCpuBusy(realTimeStart, realTimeEnd)) .setRecentCpuRate(cpuSampler.getCpuRateInfo()) .setThreadStackEntries(threadStackEntries) .flushString(); //写卡顿日志到SD卡 LogWriter.save(blockInfo.toString()); //回调添加的卡顿通知的拦截器 if (mInterceptorChain.size() != 0) &#123; for (BlockInterceptor interceptor : mInterceptorChain) &#123; interceptor.onBlock(getContext().provideContext(), blockInfo); &#125; &#125; &#125; &#125; &#125;, getContext().provideBlockThreshold(), getContext().stopWhenDebugging())); LogWriter.cleanObsolete();&#125; 调用BlockCanary的start方法,将在BlockCanaryInternals中创建的LooperMonitor给主线程Looper的mLogging变量赋值。这样主线程Looper就可以消息分发前后使用LooperMonitor#println输出日志。 1234567public void start() &#123; if (!mMonitorStarted) &#123; mMonitorStarted = true; //设置一个我们自定义的主线程的Looper的Printer Looper.getMainLooper().setMessageLogging(mBlockCanaryCore.monitor); &#125;&#125; 根据上面原理的分析，监控的对象主要是Main Looper的Message分发耗时情况。主线程的所有消息都在这里调度。每从MessageQueu中取出一个消息，由于我们设置了Printer为LooperMonitor，因此在调用dispatchMessage前后都可以交由我们LooperMonitor接管，由LooperMonitor.println()处理。对于单个Message而言，logging.println(“ Dispatching”）及logging.println(Finished)成对出现，则这个方法一定的成对调用的第一次调用时，记录开始时间，并开始dump堆栈和CPU信息。123456789101112131415161718192021222324252627282930//LooperMonitor@Overridepublic void println(String x) &#123; //Debug模式下不开启监控的开关 if (mStopWhenDebugging &amp;&amp; Debug.isDebuggerConnected()) &#123; return; &#125; if (!mPrintingStarted) &#123; //第一次调用时走该分支 mStartTimestamp = System.currentTimeMillis(); mStartThreadTimestamp = SystemClock.currentThreadTimeMillis(); mPrintingStarted = true; //开始堆栈信息的dump startDump(); &#125; else &#123; //第二次调用时走该分支 final long endTime = System.currentTimeMillis(); mPrintingStarted = false; if (isBlock(endTime)) &#123; //回调onBlockEvent，生成日志，写日志并发送卡顿通知 notifyBlockEvent(endTime); &#125; //停止堆栈信息的dump的任务 stopDump(); &#125; //第二次与第一次的时间间隔是否会超过阀值 private boolean isBlock(long endTime) &#123; return endTime - mStartTimestamp &gt; mBlockThresholdMillis; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637//LooperMonitor//开始dump堆栈和CPU信息采样private void startDump() &#123; //堆栈信息采样 if (null != BlockCanaryInternals.getInstance().stackSampler) &#123; BlockCanaryInternals.getInstance().stackSampler.start(); &#125; //CPU信息采样 if (null != BlockCanaryInternals.getInstance().cpuSampler) &#123; BlockCanaryInternals.getInstance().cpuSampler.start(); &#125;&#125; //AbstractSamplerpublic void start() &#123; if (mShouldSample.get()) &#123; return; &#125; mShouldSample.set(true); HandlerThreadFactory.getTimerThreadHandler().removeCallbacks(mRunnable); HandlerThreadFactory.getTimerThreadHandler().postDelayed(mRunnable, BlockCanaryInternals.getInstance().getSampleDelay());&#125; //每隔采样时间进行一次采样,采样时间为设置的卡顿阈值的0.8倍private Runnable mRunnable = new Runnable() &#123; @Override public void run() &#123; doSample(); if (mShouldSample.get()) &#123; HandlerThreadFactory.getTimerThreadHandler() .postDelayed(mRunnable, mSampleInterval); &#125; &#125;&#125;; 两种采样依次提交到HandlerThread中进行，从而保证采样过程是在一个后台线程执行，并且不会被主线程堵塞。两种采样方法有个共同的父类AbstractSampler，采用了模板方法模式，即在父类定义了采样的抽象算法doSample及采样生命周期的管控（start和stop），不同的子类采样的算法实现是不一样的。采样时间为设置的卡顿阈值的0.8倍。通过0.8 mSampleInterval（卡顿时长阀值）后的去获取线程的堆栈信息并保存到sStackMap中，这里的意思是，我们认为方法执行超过mSampleInterval就表示卡顿，当方法执行时间已经到了mSampleInterval的0.8倍的时候还没执行完，那么这时候就开始采集方法执行堆栈信息了，如果方法在0.9 mSampleInterval的时候执行完成，那么不会警告卡顿，但是如果方法执行耗时超过mSampleInterval，那就把0.8 mSampleInterval这个时间点的堆栈信息认为是造成耗时原因的堆栈信息，而且，这里只要方法还没执行完，就会间隔mSampleInterval去再次获取函数执行堆栈信息并保存，这里之所以遥在0.8 mSampleInterval的时候就去获取堆栈信息时为了获取到准确的堆栈信息，因为既然函数耗时已经达到0.8 * mSampleInterval了，并且函数还没执行结束，那么很大概率上会导致卡顿了，所以提前获取函数执行堆栈保证获取到造成卡顿的函数调用堆栈的正确性，后面又不断间隔mSampleInterval去获取函数执行堆栈式要获取到更多完整的堆栈信息，当方法执行完成后就会停止获取函数执行堆栈了，所有的函数执行堆栈信息最多存100条，也就是最多有100个函数调用堆栈，以当前的时间戳作为key，当监测到卡顿的时候，要把之前保存在sStackMap的函数堆栈信息展示通知出来，通过时间戳就能取到。 堆栈采样很简单，直接通过Main Looper获取到主线程Thread对象，调用Thread#getStackTrace即可获取到堆栈信息。 1234567891011121314151617@Overrideprotected void doSample() &#123; StringBuilder stringBuilder = new StringBuilder(); for (StackTraceElement stackTraceElement : mCurrentThread.getStackTrace()) &#123; stringBuilder .append(stackTraceElement.toString()) .append(BlockInfo.SEPARATOR); &#125; synchronized (sStackMap) &#123; if (sStackMap.size() == mMaxEntryCount &amp;&amp; mMaxEntryCount &gt; 0) &#123; sStackMap.remove(sStackMap.keySet().iterator().next()); &#125; sStackMap.put(System.currentTimeMillis(), stringBuilder.toString()); &#125;&#125; cpu的采样是采集当前cpu的使用率，如果cpu使用率太高，可能会导致cpu处理来不及，所以函数执行到一半可能暂时挂起，等待cpu重新调度。主要通过统计/proc/stat（CPU的活动信息）及/proc/pid/stat文件（该文件包含了某一进程所有的活动的信息）中的时间，计算各个时间量utime、stime、cutime、cstime的占比得到。","categories":[{"name":"第三方源码解析","slug":"第三方源码解析","permalink":"http://yoursite.com/categories/第三方源码解析/"}],"tags":[{"name":"源码","slug":"源码","permalink":"http://yoursite.com/tags/源码/"},{"name":"性能","slug":"性能","permalink":"http://yoursite.com/tags/性能/"},{"name":"第三方库","slug":"第三方库","permalink":"http://yoursite.com/tags/第三方库/"}]}]}