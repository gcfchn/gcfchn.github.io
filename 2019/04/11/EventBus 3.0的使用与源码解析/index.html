<!DOCTYPE html>
<html>
  
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  <meta name="author" content="gcfchn">
  
  
  <title>EventBus 3.0的使用与源码解析 | Hexo</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="第三方源码解析,多线程,源码,线程通信,第三方,">
  

  
  <meta name="description" content="当我们在进行Android项目开发的时候，通常要遇到需要在应用程序的各组之间、组件与后台线程之间进行通信，比如在子线程中进行数据的请求，当数据请求完毕后通过Handler或者是广播通知UI更新，而两个Fragment之间可以通过注册Listener进行通信等等。但是使用Intent、Handler、Broadcast进行组件之间、组件与后台线程之间进行通信，会增加大量代码，并且导致各通信模块之间的高度耦合。本文将EventBus 3.0的使用及相关的原理进行介绍。">

  

  <script src="//cdn.jsdelivr.net/npm/leancloud-storage@3.11.1/dist/av-min.js" async></script>

  
    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script>
  

  

  

  <script>
  // theme-ad's config script
  // it can be used in every script
  
  window.AD_CONFIG = {
    leancloud: {"appid":"Hyq9wkH495DgNHWhDQCOfQSp-gzGzoHsz","appkey":"WaR7nrzhliHj9aVwdQzkdlGd","comment":false,"count":false},
    welcome: {"enable":true,"interval":30},
    start_time: "2016-12-10",
    passwords: ["efe07af7441da2b69c4a41e42e73be4db47f66010a56900788a458354a7373ec", ],
    is_post: true,
    lock: false,
    author: "gcfchn",
    share: {"twitter":false,"facebook":false,"weibo":false,"qq":false,"wechat":false},
    mathjax: true,
    page_type: "",
    root: "/"
  };
</script>

  <script src="/vendor/sha256.min.js"></script>
<script src="/js/auth.js"></script>
<script src="/js/index.js"></script>
<script src="/vendor/qrcode.min.js"></script>

  
    <link rel="icon" href="/images/favicon.ico">
    <link rel="apple-touch-icon" href="/images/touch-icon.png">
  

  <link href="//netdna.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">

  <link rel="stylesheet" href="/css/index.css">
<link rel="stylesheet" href="/styles/components/highlight/highlight.css">

  
</head>
  <body>
    <header class="site-header">
  <div class="site-header-brand">
    
      <span class="site-header-brand-title">
        <a href="/">GCFCHN</a>
      </span>
    
    
      <span class="site-header-brand-motto"> | 安静写些东西</span>
    
  </div>
  <div class="site-header-right">
    <nav class="site-header-navigation">
      
        <a href="/" target="_self">首页</a>
      
        <a href="/archives/" target="_self">归档</a>
      
        <a href="/tags/" target="_self">标签</a>
      
        <a href="/categories/" target="_self">分类</a>
      
    </nav>
    <div class="site-header-btn">
      
      <a href="javascript:void(0);" id="site-search">
        <i class="fa fa-search"></i>
      </a>
      <a href="javascript:void(0);" id="site-nav-btn">
        <i class="fa fa-ellipsis-v"></i>
      </a>
    </div>
  </div>
</header>
<nav class="table-content" id="site-nav">
  <div class="table-content-title">
    <span>导航</span>
  </div>
  <div class="table-content-main">
    <ol class="toc">
      
        <li class="toc-item">
          <a href="/" target="_self">
            首页
          </a>
        </li>
      
        <li class="toc-item">
          <a href="/archives/" target="_self">
            归档
          </a>
        </li>
      
        <li class="toc-item">
          <a href="/tags/" target="_self">
            标签
          </a>
        </li>
      
        <li class="toc-item">
          <a href="/categories/" target="_self">
            分类
          </a>
        </li>
      
    </ol>
  </div>
</nav>
<div id="site-process"></div>
    <main>
      
  <div class="passage">
  <div class="passage-meta">
    <span>
      <i class="fa fa-calendar"></i>2019-04-11
    </span>
    
      <span>
        | <a href="/categories/第三方源码解析/"><i class="fa fa-bookmark"></i>第三方源码解析</a>
      </span>
    
    
      <span>
        | <i class="fa fa-unlock-alt"></i>UNLOCK
      </span>
    
  </div>
  <h1 class="passage-title">
    EventBus 3.0的使用与源码解析
  </h1>
  
  <article class="passage-article">
    <p></p>
<h2 id="1-使用EventBus的意义"><a href="#1-使用EventBus的意义" class="headerlink" title="1.使用EventBus的意义"></a>1.使用EventBus的意义</h2><p>EventBus是一个基于观察者模式的事件发布/订阅框架，不需要以层层传递接口的形式去单独构建通信桥梁，能够简化各组件间的通信，有效地分离事件发送方和接收，能避免复杂和容易出错的依赖性和生命周期问题，同时简化代码的书写。</p>
<h2 id="2-EventBus-3-0的使用"><a href="#2-EventBus-3-0的使用" class="headerlink" title="2.EventBus 3.0的使用"></a>2.EventBus 3.0的使用</h2><h4 id="EventBus事件通信的三要素："><a href="#EventBus事件通信的三要素：" class="headerlink" title="EventBus事件通信的三要素："></a>EventBus事件通信的三要素：</h4><ul>
<li>Event 事件。它可以是任意类型。</li>
<li>Subscriber 事件订阅者。在EventBus3.0的订阅者事件处理的方法名可以随意取，不过需要加上注解@subscribe()，并且指定线程模型，默认是POSTING。</li>
<li>Publisher 事件的发布者。我们可以在任意线程里发布事件，一般情况下，使用EventBus.getDefault()就可以得到一个EventBus对象，然后再调用post(Object)方法即可。</li>
<li></li>
</ul>
<h4 id="EventBus3-0的四种线程模型："><a href="#EventBus3-0的四种线程模型：" class="headerlink" title="EventBus3.0的四种线程模型："></a>EventBus3.0的四种线程模型：</h4><ul>
<li>POSTING (默认)  表示事件处理函数的线程跟发布事件的线程在同一个线程。</li>
<li>MAIN 表示事件处理函数的线程在主线程(UI线程)，因此在这里不能进行耗时操作。</li>
<li>BACKGROUND 表示事件处理函数的线程在后台线程，因此不能进行UI操作。如果发布事件的线程是主线程(UI线程)，那么事件处理函数将会开启一个后台线程，如果果发布事件的线程是在后台线程，那么事件处理函数就使用该线程。</li>
<li>ASYNC 表示无论事件发布的线程是哪一个，事件处理函数始终会新建一个子线程运行，同样不能进行UI操作。</li>
</ul>
<h4 id="EventBus的基本用法"><a href="#EventBus的基本用法" class="headerlink" title="EventBus的基本用法"></a>EventBus的基本用法</h4><p>1.首先需要在一个Activity里注册EventBus事件，然后定义接收方法，这跟Android里的广播机制很像，你需要首先注册广播，然后需要编写内部类，实现接收广播，然后操作UI。所以，在EventBus中，你同样得这么做。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义一个事件类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageEvent</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="title">MessageEvent</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.message=message;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMessage</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个类就是一个Bean类，里面定义用来传输的数据的类型。     </p>
<p>2.当我们需要在Activity或者Fragment里订阅事件时，我们需要注册EventBus。我们一般选择在Activity的onCreate()方法里去注册EventBus，在onDestory()方法里，去解除注册。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;           </span><br><span class="line">     <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">     setContentView(R.layout.activity_main)；</span><br><span class="line">     <span class="comment">//注册事件</span></span><br><span class="line">     EventBus.getDefault().register(<span class="keyword">this</span>)；</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onDestroy();</span><br><span class="line">    <span class="comment">//解除注册</span></span><br><span class="line">    EventBus.getDefault().unregister(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.在子线程或组件中发送事件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//发送事件</span><br><span class="line">EventBus.getDefault().post(messageEvent);</span><br></pre></td></tr></table></figure></p>
<p>自定义处理事件的方法，处理消息的方法名字可以随便取。但是需要加一个注解@Subscribe，并且要指定线程模型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//处理事件</span><br><span class="line">@Subscribe(threadMode = ThreadMode.MAIN)</span><br><span class="line">public void XXX(MessageEvent messageEvent) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="EventBus用法之粘性事件"><a href="#EventBus用法之粘性事件" class="headerlink" title="EventBus用法之粘性事件"></a>EventBus用法之粘性事件</h4><p>所谓粘性事件，就是在发送事件之后再订阅该事件也能收到该事件。请注意这里与普通事件的区别，普通事件是先注册在绑定。比如在项目中有这样的需求，在FirstActivity发送事件，到SecondActivity中做事件的处理。如果是使通过EventBus.getDefault.post(xx)发出的,在SecondActivity是接收不到消息的。主要原因是SecondActivit用于接收消息的EventBus还未完成注册，也就是发布者发了消息,但订阅者还未产生。粘性事件与普通事件处理差异如下：<br>首先发送粘性事件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//发送粘性事件</span><br><span class="line">EventBus.getDefault().postSticky(messageEvent);</span><br></pre></td></tr></table></figure>
<p>以Sticky的形式发送的事件，在注册对象也要通过Sticky的形式进行处理事件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//处理粘性事件</span><br><span class="line">@Subscribe(threadMode = ThreadMode.MAIN,sticky = true)</span><br><span class="line">public void XXX(MessageEvent messageEvent) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-EventBus-3-0源码解析"><a href="#3-EventBus-3-0源码解析" class="headerlink" title="3.EventBus 3.0源码解析"></a>3.EventBus 3.0源码解析</h2><p>在进入主题之前，我们先保持着这样几个疑问，EventBus的使用三要素里，我们为什么要去定义事件方法，并且用到了@subscribe()注解？EventBus.getDefault().register(Object)这行代码到底干了什么？发送事件的时候又做了哪些操作？为什么要在onDestory()做解除绑定的操作…等等</p>
<h4 id="3-1注册-EventBus-getDefault-register-obj"><a href="#3-1注册-EventBus-getDefault-register-obj" class="headerlink" title="3.1注册:EventBus.getDefault().register(obj)"></a>3.1注册:EventBus.getDefault().register(obj)</h4><p>首先调用EventBus的静态getDefault()方法返回一个EventBus对象，采用单例实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  静态的单例</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> EventBus defaultInstance;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认的EventBusBuilder对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> EventBusBuilder DEFAULT_BUILDER = <span class="keyword">new</span> EventBusBuilder();</span><br><span class="line"></span><br><span class="line"><span class="comment">//  使用了单例的双重检查锁机制</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EventBus <span class="title">getDefault</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (defaultInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (EventBus.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (defaultInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    defaultInstance = <span class="keyword">new</span> EventBus();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> defaultInstance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//  调用带参数的构造方法</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">EventBus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>(DEFAULT_BUILDER);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  </span></span><br><span class="line"> EventBus(EventBusBuilder builder) &#123;</span><br><span class="line">        <span class="comment">//...       </span></span><br><span class="line">       subscriptionsByEventType = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        typesBySubscriber = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        stickyEvents = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">        mainThreadPoster = <span class="keyword">new</span> HandlerPoster(<span class="keyword">this</span>, Looper.getMainLooper(), <span class="number">10</span>);</span><br><span class="line">        backgroundPoster = <span class="keyword">new</span> BackgroundPoster(<span class="keyword">this</span>);</span><br><span class="line">        asyncPoster = <span class="keyword">new</span> AsyncPoster(<span class="keyword">this</span>);</span><br><span class="line">        indexCount = builder.subscriberInfoIndexes != <span class="keyword">null</span> ? builder.subscriberInfoIndexes.size() : <span class="number">0</span>;</span><br><span class="line">        subscriberMethodFinder = <span class="keyword">new</span> SubscriberMethodFinder(builder.subscriberInfoIndexes,</span><br><span class="line">                builder.strictMethodVerification, builder.ignoreGeneratedIndex);</span><br><span class="line">        logSubscriberExceptions = builder.logSubscriberExceptions;</span><br><span class="line">        logNoSubscriberMessages = builder.logNoSubscriberMessages;</span><br><span class="line">        sendSubscriberExceptionEvent = builder.sendSubscriberExceptionEvent;</span><br><span class="line">        sendNoSubscriberEvent = builder.sendNoSubscriberEvent;</span><br><span class="line">        throwSubscriberException = builder.throwSubscriberException;</span><br><span class="line">        eventInheritance = builder.eventInheritance;</span><br><span class="line">        executorService = builder.executorService;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>在EventBus(builder)构造方法里初始化了一些配置信息。<br>之后调用了EventBus的register(obj)方法，这个方法接收的参数类型是Object。这里我们分步骤1和步骤2去看看做了哪些操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public void register(Object subscriber) &#123;</span><br><span class="line">    //通过反射拿到传入的obj的Class对象</span><br><span class="line">    //如果是在MainActivity里做的注册操作，那subscriber就是MainActivity对象</span><br><span class="line">    Class&lt;?&gt; subscriberClass = subscriber.getClass();</span><br><span class="line">    //步骤1 </span><br><span class="line">    List&lt;SubscriberMethod&gt; subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass);</span><br><span class="line">    //步骤2</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        for (SubscriberMethod subscriberMethod : subscriberMethods) &#123;</span><br><span class="line">            subscribe(subscriber, subscriberMethod);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>步骤1:首先subscriberMethodFinder对象是在EventBus带参数的构造函数里进行初始化的，从这个findSubscriberMethods()方法名就可以看出来，步骤1的是去获取当前注册的对象里所有的被@Subscribe注解的方法集合，那这个List集合的对象SubscriberMethod又是什么东东呢？我们去看一下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class SubscriberMethod &#123;</span><br><span class="line">    final Method method;//Method方法名</span><br><span class="line">    final ThreadMode threadMode;//线程模型</span><br><span class="line">    final Class&lt;?&gt; eventType;//事件的class对象</span><br><span class="line">    final int priority;//接收事件的优先级</span><br><span class="line">    final boolean sticky;//是否是粘性事件</span><br><span class="line">    String methodString;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>…</p>
<p>SubscriberMethod对这些信息做了一个封装。这些信息在我们处理事件的时候都会用到：<br>@Subscribe(threadMode = ThreadMode.MAIN,sticky = true)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void XXX(MessageEvent messageEvent) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好的，知道了SubscriberMethod是什么东东后，我们直接进入findSubscriberMethods(subscriberClass)方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">List&lt;SubscriberMethod&gt; findSubscriberMethods(Class&lt;?&gt; subscriberClass) &#123;</span><br><span class="line">     //从缓存中获取SubscriberMethod集合</span><br><span class="line">     //METHOD_CACHE是事先定义了一个缓存Map</span><br><span class="line">     //以当前的注册对象的Class对象为key</span><br><span class="line">     //注册的对象里所有的被@Subscribe注解的方法集合为value</span><br><span class="line">     List&lt;SubscriberMethod&gt; subscriberMethods = METHOD_CACHE.get(subscriberClass);</span><br><span class="line"></span><br><span class="line">    //第一次进来的时候，缓存里面没有集合，subscriberMethods为null</span><br><span class="line">    if (subscriberMethods != null) &#123;</span><br><span class="line">        return subscriberMethods;</span><br><span class="line">    &#125;</span><br><span class="line">    //ignoreGeneratedIndex属性表示是否忽略注解器生成的MyEventBusIndex</span><br><span class="line">    //ignoreGeneratedIndex是在SubscriberMethodFinder()的构造函数初始化的，默认值是 false,</span><br><span class="line">    if (ignoreGeneratedIndex) &#123;</span><br><span class="line">        //通过反射去获取 </span><br><span class="line">        subscriberMethods = findUsingReflection(subscriberClass);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">       //通过apt插件生成的代码。使用subscriber Index生成的SubscriberInfo来获取订阅者的事件处理函数，</span><br><span class="line">        subscriberMethods = findUsingInfo(subscriberClass);</span><br><span class="line">    &#125;</span><br><span class="line">    if (subscriberMethods.isEmpty()) &#123;</span><br><span class="line">        //在获得subscriberMethods以后，如果订阅者中不存在@Subscribe注解并且为public的订阅方法，则会抛出异常。</span><br><span class="line">        //即注册了监听的模块必须有一个标注了Subscribe注解方法</span><br><span class="line">        throw new EventBusException(&quot;Subscriber &quot; + subscriberClass</span><br><span class="line">                + &quot; and its super classes have no public methods with the @Subscribe annotation&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        METHOD_CACHE.put(subscriberClass, subscriberMethods);</span><br><span class="line">        return subscriberMethods;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先是从缓存中获取，如果缓存中存在直接返回，这里使用缓存有一个好处，比如在MainActivity进行了注册操作，多次启动MainActivity，就会直接去缓存中拿数据。如果缓存里没有数据，就会根据ignoreGeneratedIndex 这个boolean值去调用不同的方法，ignoreGeneratedIndex 默认为false。如果此时，获取到的方法集合还是空的，程序就会抛出异常，提醒用户被注册的对象以及它的父类没有被@Subscribe注解的public方法（这里插一句，很多时候，如果打正式包的时候EventBus没有做混淆处理，就会抛出该异常，因为方法名被混淆处理了，EventBus会找不到），把获取到的方法集合存入到缓存中去，并且把方法集合return出去。我们在项目中经常通过调用EventBus.getDefault()的单例模式来获取默认的EventBus对象，也就是ignoreGeneratedIndex为false的情况，这种情况调用了findUsingInfo方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">private List&lt;SubscriberMethod&gt; findUsingInfo(Class&lt;?&gt; subscriberClass) &#123;</span><br><span class="line">        //这里采用了享元设计模式</span><br><span class="line">        FindState findState = prepareFindState();</span><br><span class="line">        //初始化FindState里的参数</span><br><span class="line">        findState.initForSubscriber(subscriberClass);</span><br><span class="line">        while (findState.clazz != null) &#123;</span><br><span class="line">            //获取订阅者信息，没有配置MyEventBusIndex返回null</span><br><span class="line">            //如果我们通过EventBusBuilder配置了MyEventBusIndex，便会获取到subscriberInfo，调用subscriberInfo的getSubscriberMethods方法便可以得到订阅方法相关的信息，这个时候就不在需要通过注解进行获取订阅方法。</span><br><span class="line">            findState.subscriberInfo = getSubscriberInfo(findState);</span><br><span class="line">            if (findState.subscriberInfo != null) &#123;</span><br><span class="line">                SubscriberMethod[] array = findState.subscriberInfo.getSubscriberMethods();</span><br><span class="line">                for (SubscriberMethod subscriberMethod : array) &#123;</span><br><span class="line">                    if (findState.checkAdd(subscriberMethod.method, subscriberMethod.eventType)) &#123;</span><br><span class="line">                        findState.subscriberMethods.add(subscriberMethod);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                findUsingReflectionInSingleClass(findState);</span><br><span class="line">            &#125;</span><br><span class="line">             //通过反射来查找订阅方法</span><br><span class="line">            findState.moveToSuperclass();</span><br><span class="line">        &#125;</span><br><span class="line">        return getMethodsAndRelease(findState);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">//  获取FindState对象采用了享元模式</span><br><span class="line">private FindState prepareFindState() &#123;</span><br><span class="line">        synchronized (FIND_STATE_POOL) &#123;</span><br><span class="line">            for (int i = 0; i &lt; POOL_SIZE; i++) &#123;</span><br><span class="line">                FindState state = FIND_STATE_POOL[i];</span><br><span class="line">                if (state != null) &#123;</span><br><span class="line">                    FIND_STATE_POOL[i] = null;</span><br><span class="line">                    return state;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return new FindState();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">// FindState类定义的信息</span><br><span class="line">static class FindState &#123;</span><br><span class="line">        final List&lt;SubscriberMethod&gt; subscriberMethods = new ArrayList&lt;&gt;();</span><br><span class="line">        final Map&lt;Class, Object&gt; anyMethodByEventType = new HashMap&lt;&gt;();</span><br><span class="line">        final Map&lt;String, Class&gt; subscriberClassByMethodKey = new HashMap&lt;&gt;();</span><br><span class="line">        final StringBuilder methodKeyBuilder = new StringBuilder(128);</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; subscriberClass;</span><br><span class="line">        Class&lt;?&gt; clazz;</span><br><span class="line">        boolean skipSuperClasses;</span><br><span class="line">        SubscriberInfo subscriberInfo;</span><br><span class="line"></span><br><span class="line">        void initForSubscriber(Class&lt;?&gt; subscriberClass) &#123;</span><br><span class="line">            this.subscriberClass = clazz = subscriberClass;</span><br><span class="line">            skipSuperClasses = false;</span><br><span class="line">            subscriberInfo = null;</span><br><span class="line">        &#125;</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获取FindState采用了享元模式，这里不多说。之后调用了 findState.initForSubscriber(subscriberClass)方法，只是为了给FindState对象里的一些信息进行赋值操作。再然后是一个 while循环，循环里首先调用getSubscriberInfo(findState)方法，点进去看一下，发现该方法返回null。这里留一个小疑问，getSubscriberInfo()方法什么时候不为null？？ 答案在最后一节的高级用法里</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">private SubscriberInfo getSubscriberInfo(FindState findState) &#123;</span><br><span class="line">    //  findState.subscriberInfo在初始化的时候置为null，所以该if 分支不会执行</span><br><span class="line"></span><br><span class="line">    if (findState.subscriberInfo != null &amp;&amp; findState.subscriberInfo.getSuperSubscriberInfo() != null) &#123;</span><br><span class="line">        SubscriberInfo superclassInfo = findState.subscriberInfo.getSuperSubscriberInfo();</span><br><span class="line">        if (findState.clazz == superclassInfo.getSubscriberClass()) &#123;</span><br><span class="line">            return superclassInfo;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   //  subscriberInfoIndexes初始化的时候也是null，并没有赋值</span><br><span class="line">    if (subscriberInfoIndexes != null) &#123;</span><br><span class="line">        for (SubscriberInfoIndex index : subscriberInfoIndexes) &#123;</span><br><span class="line">            SubscriberInfo info = index.getSubscriberInfo(findState.clazz);</span><br><span class="line">            if (info != null) &#123;</span><br><span class="line">                return info;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以findUsingInfo()的while循环里直接走了else分支：findUsingReflectionInSingleClass(findState)。<br>也就是说findUsingInfo()方法的主要逻辑是由findUsingReflectionInSingleClass()方法去完成的(默认情况，不考虑使用apt)<br>这里有个细节要看一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">while (findState.clazz != null) &#123;</span><br><span class="line">    findState.subscriberInfo = getSubscriberInfo(findState);</span><br><span class="line">    if (findState.subscriberInfo != null) &#123;</span><br><span class="line">        SubscriberMethod[] array = findState.subscriberInfo.getSubscriberMethods();</span><br><span class="line">        for (SubscriberMethod subscriberMethod : array) &#123;</span><br><span class="line">            if (findState.checkAdd(subscriberMethod.method, subscriberMethod.eventType)) &#123;</span><br><span class="line">                findState.subscriberMethods.add(subscriberMethod);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        findUsingReflectionInSingleClass(findState);</span><br><span class="line">    &#125;</span><br><span class="line">    findState.moveToSuperclass();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个while循环什么时候结束呢？这是我们第一次看EventBus源码看到这里比较疑惑的地方，答案就在这个 findState.moveToSuperclass()里面。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void moveToSuperclass() &#123;</span><br><span class="line">    if (skipSuperClasses) &#123;</span><br><span class="line">        clazz = null;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        clazz = clazz.getSuperclass();</span><br><span class="line">        String clazzName = clazz.getName();</span><br><span class="line">        /** Skip system classes, this just degrades performance. */</span><br><span class="line">        if (clazzName.startsWith(&quot;java.&quot;) || clazzName.startsWith(&quot;javax.&quot;) || clazzName.startsWith(&quot;android.&quot;)) &#123;</span><br><span class="line">            clazz = null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到去把clazz赋值为它的超类，直到没有父类为止，才返回clazz=null，循环也才终止。也就是说 这个while循环保证了，获取注解的方法不仅会从当前注册对象里去找，也会去从他的父类查找。<br>好了，继续分析findUsingReflectionInSingleClass(findState)方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">private void findUsingReflectionInSingleClass(FindState findState) &#123;</span><br><span class="line">    Method[] methods;</span><br><span class="line">    try &#123;</span><br><span class="line">       // 查找注册对象的所有方法，注意是所有</span><br><span class="line">        methods = findState.clazz.getDeclaredMethods();</span><br><span class="line">    &#125; catch (Throwable th) &#123;</span><br><span class="line">        // Workaround for java.lang.NoClassDefFoundError, see https://github.com/greenrobot/EventBus/issues/149</span><br><span class="line">        methods = findState.clazz.getMethods();</span><br><span class="line">        findState.skipSuperClasses = true;</span><br><span class="line">    &#125;</span><br><span class="line">    //  执行遍历操作</span><br><span class="line">    for (Method method : methods) &#123;</span><br><span class="line">        //  获取该方法的修饰符,即public、private等</span><br><span class="line">        int modifiers = method.getModifiers();</span><br><span class="line"></span><br><span class="line">        // 修饰符是public才会走该分支</span><br><span class="line">        if ((modifiers &amp; Modifier.PUBLIC) != 0 &amp;&amp; (modifiers &amp; MODIFIERS_IGNORE) == 0) &#123;</span><br><span class="line">            // 这里是回去该方法的参数类型，String，in</span><br><span class="line">            Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</span><br><span class="line"></span><br><span class="line">           //  只有一个参数会走该分支</span><br><span class="line">            if (parameterTypes.length == 1) &#123;</span><br><span class="line"></span><br><span class="line">                //  如果该方法被@subscribe注解会走该分支</span><br><span class="line">                Subscribe subscribeAnnotation = method.getAnnotation(Subscribe.class);</span><br><span class="line">                if (subscribeAnnotation != null) &#123;</span><br><span class="line">                //  获取传入的对象的Class</span><br><span class="line">                    Class&lt;?&gt; eventType = parameterTypes[0];</span><br><span class="line">                    if (findState.checkAdd(method, eventType)) &#123;</span><br><span class="line">                        // 获取注解上指定的 线程模型</span><br><span class="line">                        ThreadMode threadMode = subscribeAnnotation.threadMode();</span><br><span class="line">                       // 往集合中添加数据</span><br><span class="line">                        findState.subscriberMethods.add(new SubscriberMethod(method, eventType, threadMode,</span><br><span class="line">                                subscribeAnnotation.priority(), subscribeAnnotation.sticky()));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else if (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123;</span><br><span class="line">                String methodName = method.getDeclaringClass().getName() + &quot;.&quot; + method.getName();</span><br><span class="line">                throw new EventBusException(&quot;@Subscribe method &quot; + methodName +</span><br><span class="line">                        &quot;must have exactly 1 parameter but has &quot; + parameterTypes.length);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123;</span><br><span class="line">            String methodName = method.getDeclaringClass().getName() + &quot;.&quot; + method.getName();</span><br><span class="line">            throw new EventBusException(methodName +</span><br><span class="line">                    &quot; is a illegal @Subscribe method: must be public, non-static, and non-abstract&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>findUsingReflectionInSingleClass()方法首先通过反射去拿到当前注册对象的所有的方法，然后去进行遍历，并进行第一次过滤，只针对修饰符是Public的方法，之后进行了第二次过滤，判断了方法的参数的个数是不是只有一个，如果满足，才去进一步的获取被@subscribe注解的方法。<br>然后调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">findState.subscriberMethods.add(new SubscriberMethod(method, eventType, threadMode,subscribeAnnotation.priority(), subscribeAnnotation.sticky()));</span><br></pre></td></tr></table></figure>
<p>这行代码，new了一个SubscriberMethod()对象，传入参数，并添加到 findState.subscriberMethods的集合中去.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static class FindState &#123;</span><br><span class="line">       final List&lt;SubscriberMethod&gt; subscriberMethods = new ArrayList&lt;&gt;();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>之后，findUsingInfo()的getMethodsAndRelease(findState)方法回去获取刚刚设置的findState的subscriberMethods集合，并把它return出去。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private List&lt;SubscriberMethod&gt; getMethodsAndRelease(FindState findState) &#123;</span><br><span class="line">    //  对subscriberMethods进行了赋值，return出去</span><br><span class="line">    List&lt;SubscriberMethod&gt; subscriberMethods = new ArrayList&lt;&gt;(findState.subscriberMethods);</span><br><span class="line">   //  进行了回收</span><br><span class="line">    findState.recycle();</span><br><span class="line">    synchronized (FIND_STATE_POOL) &#123;</span><br><span class="line">        for (int i = 0; i &lt; POOL_SIZE; i++) &#123;</span><br><span class="line">            if (FIND_STATE_POOL[i] == null) &#123;</span><br><span class="line">                FIND_STATE_POOL[i] = findState;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return subscriberMethods;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>步骤1总结：至此，以上就是EventBus获取一个注册对象的所有的被@subscribe注解的方法的集合的一个过程。该过程的主要方法流程为：<br>(1) subscriberMethodFinder.findSubscriberMethods()<br>(2) findUsingInfo()<br>(3) findUsingReflectionInSingleClass()<br>步骤2</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (SubscriberMethod subscriberMethod : subscriberMethods) &#123;</span><br><span class="line">          subscribe(subscriber, subscriberMethod);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>通过步骤1，我们已经拿到了注册对象的所有的被@subscribe注解的方法的集合的。现在我们看看subscribe()都做了哪些操作。<br>我们不妨想想，如果我们要去做subscribe()时，我们要考虑哪些问题，第一个问题是，要判断一下这些方法是不是已经注册过该事件了要不要考虑方法名是不是相同的问题。第二个问题是一个注册对象中有多个方法注册了该事件，我们该怎么保存这些方法，比如说事件类型是String,一个Activity里有两个方法注册了该事件，分别是onEvent1和onEvent2，那我是不是应该用一个Map集合，以事件类型为key，把onEvent1和onEvent2放到一个List集合中，把该List集合作为value。<br>subscribe()方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) &#123;</span><br><span class="line">    //拿到事件event类型，比如是String或者自定义的对象</span><br><span class="line">    Class&lt;?&gt; eventType = subscriberMethod.eventType;</span><br><span class="line">    </span><br><span class="line">    //Subscription将注册对象和subscriberMethod 做为参数传入</span><br><span class="line">    </span><br><span class="line">    Subscription newSubscription = new Subscription(subscriber, subscriberMethod);</span><br><span class="line">    </span><br><span class="line">    //subscriptionsByEventType是一个Map集合，key是事件类型，验证了我上面的猜想</span><br><span class="line">    CopyOnWriteArrayList&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType);</span><br><span class="line">    </span><br><span class="line">    //如果subscriptions是null,则new出一个CopyOnWriteArrayList，并且往Map集合中添加</span><br><span class="line">    if (subscriptions == null) &#123;</span><br><span class="line">        subscriptions = new CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line">        subscriptionsByEventType.put(eventType, subscriptions);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">    </span><br><span class="line">    //这里做了if语句判断，判断一下List集合中是否存在，存在就抛异常</span><br><span class="line">    //如果不存在？怎么没有add操作？保持疑问</span><br><span class="line">    </span><br><span class="line">        if (subscriptions.contains(newSubscription)) &#123;</span><br><span class="line">            throw new EventBusException(&quot;Subscriber &quot; + subscriber.getClass() + &quot; already registered to event &quot;</span><br><span class="line">                    + eventType);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上的操作验证了我之前的猜想，通过if (subscriptions.contains(newSubscription))  这个if语句判断 是否发生了重复注册，注意这里重复注册的含义是 事件类型一致，以及方法名也一致。<br>接下来我们看看如果一个注册对象重复注册了事件Event(方法名不能一致)，优先级priority是如何设置的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int size = subscriptions.size();</span><br><span class="line">for (int i = 0; i &lt;= size; i++) &#123;</span><br><span class="line"></span><br><span class="line">  //  这里判断subscriberMethod的优先级是否是大于集合中的subscriberMethod的优先级，如果是，把newSubscription插进去</span><br><span class="line"> //  这也表明了subscription中priority大的在前，这样在事件分发时就会先获取。</span><br><span class="line">         if (i == size || subscriberMethod.priority &gt; subscriptions.get(i).subscriberMethod.priority) &#123;</span><br><span class="line">            subscriptions.add(i, newSubscription);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>if语句的条件subscriberMethod.priority &gt; subscriptions.get(i).subscriberMethod.priority) ，保证了subscription中priority大的在前。同时i == size 这个条件也保证了priority小的也会添加到subscriptions集合中去<br>紧接着我们看看EventBus是如何处理粘性事件的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Class&lt;?&gt;&gt; subscribedEvents = typesBySubscriber.get(subscriber);</span><br><span class="line">    if (subscribedEvents == null) &#123;</span><br><span class="line">        subscribedEvents = new ArrayList&lt;&gt;();</span><br><span class="line">        typesBySubscriber.put(subscriber, subscribedEvents);</span><br><span class="line">    &#125;</span><br><span class="line">    subscribedEvents.add(eventType);</span><br><span class="line"></span><br><span class="line">    if (subscriberMethod.sticky) &#123;</span><br><span class="line">        if (eventInheritance) &#123;</span><br><span class="line">            // Existing sticky events of all subclasses of eventType have to be considered.</span><br><span class="line">            // Note: Iterating over all events may be inefficient with lots of sticky events,</span><br><span class="line">            // thus data structure should be changed to allow a more efficient lookup</span><br><span class="line">            // (e.g. an additional map storing sub classes of super classes: Class -&gt; List&lt;Class&gt;).</span><br><span class="line">            Set&lt;Map.Entry&lt;Class&lt;?&gt;, Object&gt;&gt; entries = stickyEvents.entrySet();</span><br><span class="line">            for (Map.Entry&lt;Class&lt;?&gt;, Object&gt; entry : entries) &#123;</span><br><span class="line">                Class&lt;?&gt; candidateEventType = entry.getKey();</span><br><span class="line">                if (eventType.isAssignableFrom(candidateEventType)) &#123;</span><br><span class="line">                    Object stickyEvent = entry.getValue();</span><br><span class="line">                    checkPostStickyEventToSubscription(newSubscription, stickyEvent);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            Object stickyEvent = stickyEvents.get(eventType);</span><br><span class="line">            checkPostStickyEventToSubscription(newSubscription, stickyEvent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意以上代码有四行比较重要的注释信息。大致的意思是必须考虑eventType所有子类的现有粘性事件，在迭代的过程中，所有的event可能会因为大量的sticky events变得低效，为了使得查询变得高效应该改变数据结构。<br>isAssignableFrom方法的意思是判断candidateEventType是不是eventType的子类或者子接口，如果postSticky()的参数是子Event,那么@Subscribe注解方法中的参数是父Event也可以接收到此消息。<br>拿到粘性Event后，调用了checkPostStickyEventToSubscription()方法，改方法内部方法内部调用了postToSubscription()<br>private void checkPostStickyEventToSubscription(Subscription newSubscription, Object stickyEvent) {<br>        if (stickyEvent != null) {<br>            // If the subscriber is trying to abort the event, it will fail (event is not tracked in posting state)<br>            // –&gt; Strange corner case, which we don’t take care of here.<br>            postToSubscription(newSubscription, stickyEvent, Looper.getMainLooper() == Looper.myLooper());<br>        }<br>    }</p>
<p>步骤2总结：至此，EventBus的注册操作已经全部分析完了，需要注意的是，粘性事件是在subscribe中进行post的<br>(二)  发送事件：EventBus.getDefault().post(xxx);<br>普通Event</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public void post(Object event) &#123;</span><br><span class="line">    PostingThreadState postingState = currentPostingThreadState.get();</span><br><span class="line">    List&lt;Object&gt; eventQueue = postingState.eventQueue;</span><br><span class="line">   //  将Event添加到List集合中去</span><br><span class="line">    eventQueue.add(event);</span><br><span class="line"></span><br><span class="line">    if (!postingState.isPosting) &#123;</span><br><span class="line">        postingState.isMainThread = Looper.getMainLooper() == Looper.myLooper();</span><br><span class="line">        postingState.isPosting = true;</span><br><span class="line">        if (postingState.canceled) &#123;</span><br><span class="line">            throw new EventBusException(&quot;Internal error. Abort state was not reset&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">           // 遍历这个list集合，条件是集合是否是空的</span><br><span class="line">            while (!eventQueue.isEmpty()) &#123;</span><br><span class="line">                postSingleEvent(eventQueue.remove(0), postingState);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            postingState.isPosting = false;</span><br><span class="line">            postingState.isMainThread = false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先将当前的 Event添加到eventQueue中去，并且while循环，处理post每一个Event事件，调用的是 postSingleEvent(eventQueue.remove(0), postingState);</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">private void postSingleEvent(Object event, PostingThreadState postingState) throws Error &#123;</span><br><span class="line">        //  获取Event的Class对象</span><br><span class="line">        Class&lt;?&gt; eventClass = event.getClass();</span><br><span class="line">        boolean subscriptionFound = false;</span><br><span class="line"></span><br><span class="line">       //  eventInheritance初始化的时候值为true，所以会走该分支</span><br><span class="line">        if (eventInheritance) &#123;</span><br><span class="line">       //  获取当前的Event的Class对象的所有父类的Class对象集合，优先从缓存里读取。</span><br><span class="line">            List&lt;Class&lt;?&gt;&gt; eventTypes = lookupAllEventTypes(eventClass);</span><br><span class="line">            int countTypes = eventTypes.size();</span><br><span class="line">            for (int h = 0; h &lt; countTypes; h++) &#123;</span><br><span class="line">                Class&lt;?&gt; clazz = eventTypes.get(h);</span><br><span class="line">                subscriptionFound |= postSingleEventForEventType(event, postingState, clazz);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            subscriptionFound = postSingleEventForEventType(event, postingState, eventClass);</span><br><span class="line">        &#125;</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里lookupAllEventTypes()方法也是为了获取当前的Event的Class对象的所有父类的Class对象集合，优先从缓存里读取。<br>之后是 for循环获取到的Class对象集合，调用postSingleEventForEventType()方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">private boolean postSingleEventForEventType(Object event, PostingThreadState postingState, Class&lt;?&gt; eventClass) &#123;</span><br><span class="line">        CopyOnWriteArrayList&lt;Subscription&gt; subscriptions;</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">        // subscriptionsByEventType该map是在subscribe()方法中进行了put操作</span><br><span class="line">            subscriptions = subscriptionsByEventType.get(eventClass);</span><br><span class="line">        &#125;</span><br><span class="line">        if (subscriptions != null &amp;&amp; !subscriptions.isEmpty()) &#123;</span><br><span class="line">            for (Subscription subscription : subscriptions) &#123;</span><br><span class="line">                postingState.event = event;</span><br><span class="line">                postingState.subscription = subscription;</span><br><span class="line">                boolean aborted = false;</span><br><span class="line">                try &#123;</span><br><span class="line">                   // 进行for循环并调用了postToSubscription()</span><br><span class="line">                    postToSubscription(subscription, event, postingState.isMainThread);</span><br><span class="line">                    aborted = postingState.canceled;</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    postingState.event = null;</span><br><span class="line">                    postingState.subscription = null;</span><br><span class="line">                    postingState.canceled = false;</span><br><span class="line">                &#125;</span><br><span class="line">                if (aborted) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>postSingleEventForEventType()方法，主要是获取Event的Class对象所对应的一个List集合，集合的对象是Subscription参数。subscriptionsByEventType对象是在subscribe()方法中进行了赋值。<br>for循环CopyOnWriteArrayList集合，并调用postToSubscription()；<br>线程模型<br>等执行到postToSubscription()方法时，线程模型才派上了用场。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">private void postToSubscription(Subscription subscription, Object event, boolean isMainThread) &#123;</span><br><span class="line">        switch (subscription.subscriberMethod.threadMode) &#123;</span><br><span class="line">            case POSTING:</span><br><span class="line">                invokeSubscriber(subscription, event);</span><br><span class="line">                break;</span><br><span class="line">            case MAIN:</span><br><span class="line">                if (isMainThread) &#123;</span><br><span class="line">                    invokeSubscriber(subscription, event);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    mainThreadPoster.enqueue(subscription, event);</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            case BACKGROUND:</span><br><span class="line">                if (isMainThread) &#123;</span><br><span class="line">                    backgroundPoster.enqueue(subscription, event);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    invokeSubscriber(subscription, event);</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            case ASYNC:</span><br><span class="line">                asyncPoster.enqueue(subscription, event);</span><br><span class="line">                break;</span><br><span class="line">            default:</span><br><span class="line">                throw new IllegalStateException(&quot;Unknown thread mode: &quot; + subscription.subscriberMethod.threadMode);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>第一个分支：线程模型是POST，直接调用了invokeSubscriber()方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void invokeSubscriber(Subscription subscription, Object event) &#123;</span><br><span class="line">     try &#123;</span><br><span class="line">         subscription.subscriberMethod.method.invoke(subscription.subscriber, event);</span><br><span class="line">     &#125; catch (InvocationTargetException e) &#123;</span><br><span class="line">         handleSubscriberException(subscription, event, e.getCause());</span><br><span class="line">     &#125; catch (IllegalAccessException e) &#123;</span><br><span class="line">         throw new IllegalStateException(&quot;Unexpected exception&quot;, e);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>很明显的看到，这是基于反射去调用方法，invoke方法接收两个参数，第一个参数是注册的对象，第二个参数是事件的Event。<br>从这里就可以看出来，POST并没有去做线程的调度什么的，事件处理函数的线程跟发布事件的线程在同一个线程。<br>第二个分支：线程模型是MAIN  首先判断了下事件发布的线程是不是主线程，如果是，执行invokeSubscriber()方法，invokeSubscriber()上面已经分析过，如果不是主线程，执行mainThreadPoster.enqueue(subscription, event)。<br>mainThreadPoster是继承自Handler，从这里大概可以猜到，这一步是去做线程调度的。<br>我们看一看mainThreadPoster的enqueue做了什么事：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void enqueue(Subscription subscription, Object event) &#123;</span><br><span class="line">        //  封装了一个PendIngPost</span><br><span class="line">        PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event);</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            // 将PendIngPost压入队列</span><br><span class="line">            queue.enqueue(pendingPost);</span><br><span class="line">            if (!handlerActive) &#123;</span><br><span class="line">                handlerActive = true;</span><br><span class="line">                //  调用了sendMessage()</span><br><span class="line">                if (!sendMessage(obtainMessage())) &#123;</span><br><span class="line">                    throw new EventBusException(&quot;Could not send handler message&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>enqueue() 主要封装了一个PendingPost类，并把subscription和event作为参数传进去，紧接着把PendingPost压入到队列中去，然后发了一条消息sendMessage。<br>熟悉Handler机制的同学知道，处理消息是在handleMessage()方法中完成的:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public void handleMessage(Message msg) &#123;</span><br><span class="line">        boolean rescheduled = false;</span><br><span class="line">        try &#123;</span><br><span class="line">            long started = SystemClock.uptimeMillis();</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                PendingPost pendingPost = queue.poll();</span><br><span class="line">                if (pendingPost == null) &#123;</span><br><span class="line">                    synchronized (this) &#123;</span><br><span class="line">                        // Check again, this time in synchronized</span><br><span class="line">                        pendingPost = queue.poll();</span><br><span class="line">                        if (pendingPost == null) &#123;</span><br><span class="line">                            handlerActive = false;</span><br><span class="line">                            return;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                eventBus.invokeSubscriber(pendingPost);</span><br><span class="line">                long timeInMethod = SystemClock.uptimeMillis() - started;</span><br><span class="line">                if (timeInMethod &gt;= maxMillisInsideHandleMessage) &#123;</span><br><span class="line">                    if (!sendMessage(obtainMessage())) &#123;</span><br><span class="line">                        throw new EventBusException(&quot;Could not send handler message&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                    rescheduled = true;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            handlerActive = rescheduled;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>代码有点多，我们主要看一下，它接收到消息后，是做了什么处理。从队列中取了消息，并且调用了eventBus.invokeSubscriber(pendingPost)方法，回到EventBus类中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void invokeSubscriber(PendingPost pendingPost) &#123;</span><br><span class="line">        Object event = pendingPost.event;</span><br><span class="line">        Subscription subscription = pendingPost.subscription;</span><br><span class="line">        PendingPost.releasePendingPost(pendingPost);</span><br><span class="line">        if (subscription.active) &#123;</span><br><span class="line">            invokeSubscriber(subscription, event);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>该方法内部还是去调用了invokeSubscriber()方法。<br>分析完线程模型为MAIN 的工作流程，不难做出结论，当发布事件所在的线程是在主线程时，我们不需要做线程调度，直接调用反射方法去执行。如果发布事件所在的线程不是在主线程，需要使用Handler做线程的调度，并最终调用反射方法去执行<br>第三个分支：线程模型是BACKGROUND。如果事件发布的线程是在主线程，执行<br>backgroundPoster.enqueue(subscription, event)，否则执行invokeSubscriber()。<br>backgroundPoster实现了Runable接口:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public void enqueue(Subscription subscription, Object event) &#123;</span><br><span class="line">        PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event);</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            queue.enqueue(pendingPost);</span><br><span class="line">            if (!executorRunning) &#123;</span><br><span class="line">                executorRunning = true;</span><br><span class="line">                eventBus.getExecutorService().execute(this);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>将PendingPost对象压入队列，然后调用eventBus.getExecutorService().execute(this)，交给线程池去进行处理，它的处理是在Runnable的run()中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                while (true) &#123;</span><br><span class="line">                    PendingPost pendingPost = queue.poll(1000);</span><br><span class="line">                    if (pendingPost == null) &#123;</span><br><span class="line">                        synchronized (this) &#123;</span><br><span class="line">                            // Check again, this time in synchronized</span><br><span class="line">                            pendingPost = queue.poll();</span><br><span class="line">                            if (pendingPost == null) &#123;</span><br><span class="line">                                executorRunning = false;</span><br><span class="line">                                return;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    eventBus.invokeSubscriber(pendingPost);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                Log.w(&quot;Event&quot;, Thread.currentThread().getName() + &quot; was interruppted&quot;, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            executorRunning = false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>最重要的还是eventBus.invokeSubscriber(pendingPost)这行代码，上面已经分析过。<br>第四个分支：线程模型是ASYNC。直接调用 asyncPoster.enqueue(subscription, event)，asyncPoster也是实现了Runnable接口，里面也是使用的线程池，具体的操作就不分析了，感兴趣的可以去看一下源码，跟上一步操作类似。<br>(三) 高级用法<br>EventBus3.0较之前的版本有了一次改造，在3.0之后增加了注解处理器，在程序的编译时候，就可以根据注解生成相对应的代码，相对于之前的直接通过运行时反射，大大提高了程序的运行效率，但是在3.0默认的还是通过反射去查找用@Subscribe标注的方法，一般在使用的时候基本都是这个模式。  那我们怎么配置让EventBus使用注解器生成的代码呢？<br>EventBus官网apt介绍<br>在这里我们重点提一下 EventBusBuilder类的：</p>
<p>boolean ignoreGeneratedIndex;<br>List<subscriberinfoindex> subscriberInfoIndexes;</subscriberinfoindex></p>
<p>subscriberInfoIndexes变量可以去使用注解处理器生成的代码。SubscriberInfoIndex 就是一个接口，而注解生成器生成的类也是继承的它，我们也可以自己去继承它，定制自己的需求，不需要反射的EventBus。<br>我们再回过头来看一下注册过程的findUsingInfo()方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">private List&lt;SubscriberMethod&gt; findUsingInfo(Class&lt;?&gt; subscriberClass) &#123;</span><br><span class="line">        FindState findState = prepareFindState();</span><br><span class="line">        findState.initForSubscriber(subscriberClass);</span><br><span class="line">        while (findState.clazz != null) &#123;</span><br><span class="line">            findState.subscriberInfo = getSubscriberInfo(findState);</span><br><span class="line">            if (findState.subscriberInfo != null) &#123;</span><br><span class="line">                SubscriberMethod[] array = findState.subscriberInfo.getSubscriberMethods();</span><br><span class="line">                for (SubscriberMethod subscriberMethod : array) &#123;</span><br><span class="line">                    if (findState.checkAdd(subscriberMethod.method, subscriberMethod.eventType)) &#123;</span><br><span class="line">                        findState.subscriberMethods.add(subscriberMethod);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                findUsingReflectionInSingleClass(findState);</span><br><span class="line">            &#125;</span><br><span class="line">            findState.moveToSuperclass();</span><br><span class="line">        &#125;</span><br><span class="line">        return getMethodsAndRelease(findState);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>我们在前面分析的时候，直接分析的  findUsingReflectionInSingleClass(findState)方法，因为getSubscriberInfo()返回null，那什么时候getSubscriberInfo()返回不为null呢 ？ 我们具体看看getSubscriberInfo()。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private SubscriberInfo getSubscriberInfo(FindState findState) &#123;</span><br><span class="line">       if (findState.subscriberInfo != null &amp;&amp; findState.subscriberInfo.getSuperSubscriberInfo() != null) &#123;</span><br><span class="line">           SubscriberInfo superclassInfo = findState.subscriberInfo.getSuperSubscriberInfo();</span><br><span class="line">           if (findState.clazz == superclassInfo.getSubscriberClass()) &#123;</span><br><span class="line">               return superclassInfo;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">      //  判断subscriberInfoIndexes 是否为null，默认为null,当我们使用apt插件构建代码 的时候，可以手动的调用EventBusBuilder的addIndex，将subscriberInfoIndexes 进行赋值。</span><br><span class="line">       if (subscriberInfoIndexes != null) &#123;</span><br><span class="line">           for (SubscriberInfoIndex index : subscriberInfoIndexes) &#123;</span><br><span class="line">               SubscriberInfo info = index.getSubscriberInfo(findState.clazz);</span><br><span class="line">               if (info != null) &#123;</span><br><span class="line">                   return info;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return null;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>当我们使用apt插件构建代码 的时候，可以手动的调用EventBusBuilder的addIndex()，将subscriberInfoIndexes 进行赋值。这样subscriberInfoIndexes 就不会为null，getSubscriberInfo()方法也就不会为null。findUsingInfo()也就不会调用反射去获取数据，从而提高了性能。<br>如何使用新特性SubscriberIndex：<br>在gradle文件做以下配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        javaCompileOptions &#123;</span><br><span class="line">            annotationProcessorOptions &#123;</span><br><span class="line">                arguments = [ eventBusIndex : &apos;com.example.myapp.MyEventBusIndex&apos; ]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile &apos;org.greenrobot:eventbus:3.1.1&apos;</span><br><span class="line">    annotationProcessor &apos;org.greenrobot:eventbus-annotation-processor:3.1.1&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>成功构建项目后，将为您生成使用eventBusIndex指定的类 。然后在设置EventBus时将其传递给它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EventBus.builder().ignoreGeneratedIndex(false).addIndex(new MyEventBusIndex()).installDefaultEventBus();</span><br></pre></td></tr></table></figure>
<p><a href="http://www.cnblogs.com/bugly/p/5475034.html" target="_blank" rel="noopener">1.老司机教你 “飙” EventBus 3</a><br><a href="https://www.jianshu.com/p/76b18030e305" target="_blank" rel="noopener">2.Android事件总线（二）EventBus3.0源码解析</a><br><a href="https://www.jianshu.com/p/f9ae5691e1bb" target="_blank" rel="noopener">3.EventBus 3.0使用详解</a>  </p>
  </article>
  <aside class="table-content" id="site-toc">
  <div class="table-content-title">
    <i class="fa fa-arrow-right fa-lg" id="site-toc-hide-btn"></i>
    <span>目录</span>
  </div>
  <div class="table-content-main">
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-使用EventBus的意义"><span class="toc-text">1.使用EventBus的意义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-EventBus-3-0的使用"><span class="toc-text">2.EventBus 3.0的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#EventBus事件通信的三要素："><span class="toc-text">EventBus事件通信的三要素：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#EventBus3-0的四种线程模型："><span class="toc-text">EventBus3.0的四种线程模型：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#EventBus的基本用法"><span class="toc-text">EventBus的基本用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#EventBus用法之粘性事件"><span class="toc-text">EventBus用法之粘性事件</span></a></li></ol></li></ol><li class="toc-item toc-level-2"><a class="toc-link" href="#3-EventBus-3-0源码解析"><span class="toc-text">3.EventBus 3.0源码解析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1注册-EventBus-getDefault-register-obj"><span class="toc-text">3.1注册:EventBus.getDefault().register(obj)</span></a></li></ol></li>
  </div>
</aside>
  
    <aside class="passage-copyright">
      <div>本文作者: gcfchn</div>
      
        <div>
          原文链接: 
          <a href target="_blank">http://yoursite.com/2019/04/11/EventBus 3.0的使用与源码解析/</a>
        </div>
      
      <div>
        著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
      </div>
    </aside>
  
  
    <div class="passage-tags">
     
      <a href="/tags/多线程/"><i class="fa fa-tags"></i>多线程</a>
     
      <a href="/tags/源码/"><i class="fa fa-tags"></i>源码</a>
     
      <a href="/tags/线程通信/"><i class="fa fa-tags"></i>线程通信</a>
     
      <a href="/tags/第三方/"><i class="fa fa-tags"></i>第三方</a>
    
    </div>
  
</div>

    </main>
    
    <div class="site-footer-wrapper">
  <footer class="site-footer">
    
      <div class="site-footer-col">
        <h5 class="site-footer-title">博客推荐</h5>
        
          <span class="site-footer-item">
            <a href="https://blog.csdn.net/lmj623565791/" target="_blank">鸿洋</a>
          </span>
        
          <span class="site-footer-item">
            <a href="http://ruanyifeng.com/" target="_blank">阮一峰的个人网站</a>
          </span>
        
      </div>
    
    <div class="site-footer-info">
      <i class="fa fa-copyright"></i> 
      2019. Created by gcfchn.
      All rights reserved.
    </div>
  </footer>
</div>
    <div id="site-layer" style="display:none;">
  <div class="site-layer-content">
    <div class="site-layer-header">
      <span class="site-layer-header-title" id="site-layer-title"></span>
      <i class="fa fa-close" id="site-layer-close"></i>
    </div>
    <div class="site-layer-body" id="site-layer-container">
      <div class="site-layer-input" id="site-layer-search" style="display: none;">
        <input type="text">
        <i class="fa fa-search"></i>
      </div>
      <div class="site-layer-reward" id="site-layer-reward" style="display: none;">
        
          <div>
            <img src="/images/wechat.png" alt="WeChat">
            
              <p>WeChat</p>
            
          </div>
        
          <div>
            <img src="/images/alipay.png" alt="AliPay">
            
              <p>AliPay</p>
            
          </div>
        
      </div>
      <div id="site-layer-welcome" style="display:none;"></div>
    </div>
  </div>
</div>
    

<div class="bottom-bar">
  <div class="bottom-bar-left">
    <a href="/2019/04/25/面向对象设计模式六大原则/" data-enable="true">
      <i class="fa fa-arrow-left"></i>
    </a>
    <a href="/2019/04/01/线程池的使用与原理解析/" data-enable="true">
      <i class="fa fa-arrow-right"></i>
    </a>
  </div>
  <div class="bottom-bar-right">
    <a href="javascript:void(0);" data-enable="true" id="site-toc-show-btn">
      <i class="fa fa-bars"></i>
    </a>
    
    <a href="javascript:void(0);" id="site-toggle-share-btn">
      <i class="fa fa-share-alt"></i>
    </a>
    <a href="javascript:void(0);" id="site-reward">
      <i class="fa fa-thumbs-up"></i>
    </a>
    <a href="javascript:void(0);" id="back-top-btn">
      <i class="fa fa-chevron-up"></i>
    </a>
  </div>
</div>
    <div id="share-btn">
  
  
  
  
  
</div>
    





    
  </body>
</html>